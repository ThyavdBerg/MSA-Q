# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MsaQgisDialog
                                 A QGIS plugin
 This plugin allows the use of the Multi Scenario Approach in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Thya van den Berg
        email                : w.b.van-den-berg-2020@hull.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# General imports
import os  # to connect to the operating system
import pickle # to create the dictionary save files
import re # for various string operations
import csv # for reading and writing .csv files
import time # for reporting date and time in the interface
from os.path import exists # for checking whether files exist before loading

# Imports from QGIS package
from PyQt5.QtCore import QTimer, QBasicTimer
from PyQt5.QtWidgets import QTableWidgetItem, QWidget, QLabel, QVBoxLayout, QComboBox,  \
    QDoubleSpinBox, QFrame, QHBoxLayout, QPushButton, QMessageBox, QFileDialog, QTableWidget
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import iface
from qgis.core import *

# Local imports from plugin package
from .MSA_QGIS_custom_widget_frame_rule_tree import RuleTreeFrame
from .MSA_QGIS_custom_widget_rule_tree import RuleTreeWidget


# This loads .ui files so that PyQt can populate the plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_base.ui'))
FORM_CLASS_TAXA, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_popup_taxa.ui'))
FORM_CLASS_VEGCOM, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_popup_vegcom.ui'))
FORM_CLASS_RULES, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_popup_add_rule.ui'))
FORM_CLASS_RULE_TREE, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_add_to_rule_tree.ui'))
FORM_CLASS_SAVELOAD, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_load_save_dialog.ui'))
FORM_CLASS_RULELIST, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA-QGIS_dialog_popup_rulelist.ui'))
FORM_CLASS_SAMPLESITE, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_popup_add_sampling_site.ui'))
FORM_CLASS_PERCENT, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_popup_add_pollen_percentages.ui'))
FORM_CLASS_SUCCES, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_succes_dialog.ui'))
FORM_CLASS_RUN, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_run_dialog.ui'))

### Main dialog window


class MsaQgisDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor for the main dialog that shows once the MSA-QGIS plugin is opened."""
        super(MsaQgisDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # Class variables
        self.extent = None
        self.check_state = -1
        self.run_type = -1
        self.save_directory = None

        # Class lists & dictionaries
        self.list_cb_rule_veg_com = []
        self.list_cb_env_var = []
        self.list_cb_rule_type = []
        self.nest_dict_rules = {}    # {'rule number': [rule_number(int), vegcom(str), chance(float), n of prev vegcoms(int),
                                # n of env vars(int), # all(bool),
                                # prevvegcom (QTableItem), AND(bool), OR(bool), nextprevvegcom...etc,
                                # envvar (QtableItem), AND(bool), OR(bool), next envvar...etc}
        self.dict_ruleTreeWidgets = {}
        self.dict_pollen_percent_files = {}

        # UI setup
        self.tab_top.setCurrentIndex(0) # Ensures the main dialog opens with the first tab shown upon startup
        self.changeAtmosConstantValue() # Calculates the first instance of the turbulence constant upon startup
        self.qgsFileWidget_importHandbag.setFilter('*.hum')
        self.label_mapFile.hide()
        self.mQgsFileWidget_startingPoint.hide()
        self.enableNested()

        # Add the custom ruleTreeFrame to the UI
        self.frame_ruleTree = RuleTreeFrame()
        self.scrollArea_ruleTree.setWidget(self.frame_ruleTree)
        self.ruleTreeLayout = QVBoxLayout()
        self.ruleTreeLayout.setSpacing(40)
        self.frame_ruleTree.setLayout(self.ruleTreeLayout)

        # Events
        self.rejected.connect(self.closeAll)
        self.doubleSpin_atmosConstant.valueChanged.connect(self.changeAtmosConstantValue)
        self.mExtentGroupBox.setMapCanvas(iface.mapCanvas())
        self.mExtentGroupBox.extentChanged.connect(self.setExtent)
        self.getFieldsandBands(self.tableWidget_vector, self.tableWidget_raster)
        self.tableWidget_vector.itemSelectionChanged.connect(lambda: self.updateSelectedRows(self.tableWidget_selected,
                                                                                      self.tableWidget_vector))
        self.tableWidget_raster.itemSelectionChanged.connect(lambda: self.updateSelectedRows(self.tableWidget_selRaster,
                                                                                             self.tableWidget_raster))
        self.pushButton_newTaxa.clicked.connect(self.addNewTaxon)
        self.pushButton_newVegCom.clicked.connect(self.addNewVegCom)
        self.pushButton_removeTaxa.clicked.connect(self.removeTaxaEntry)
        self.pushButton_removeVegCom.clicked.connect(self.removeVegComEntry)
        self.pushButton_importHandbag.clicked.connect(self.loadHandbagFile)
        self.pushButton_addRule.clicked.connect(self.addNewRule)
        self.pushButton_removeRule.clicked.connect(self.deleteRule)
        self.pushButton_ruleBelow.clicked.connect(self.addRuleToTree)
        self.pushButton_asBaseGroup.clicked.connect(self.addAndRemoveFromBaseGroup)
        self.pushButton_deleteBranch.clicked.connect(self.removeRuleFromRuleTree)
        self.pushButton_ruleSeries.clicked.connect(self.addRuleToTreeSeries)
        self.pushButton_viewList.clicked.connect(self.viewRuleList)
        self.pushButton_save.clicked.connect(self.saveFiles)
        self.pushButton_load.clicked.connect(self.loadFiles)
        self.pushButton_addSite.clicked.connect(self.addSamplingSite)
        self.pushButton_removeSite.clicked.connect(self.removeSamplingSite)
        self.pushButton_importPollen.clicked.connect(self.addPollenCountsFilePath)
        self.pushButton_removePollenFile.clicked.connect(self.removePollenCountsFilePath)
        self.pushButton_addChangeLog.clicked.connect(self.addToChangeLog)
        self.pushButton_removeChangeLog.clicked.connect(self.removeFromChangeLog)
        self.radioButton_createMap.clicked.connect(self.changeStartingPoint)
        self.radioButton_loadPointMap.clicked.connect(self.changeStartingPoint)
        self.radioButton_loadBaseMap.clicked.connect(self.changeStartingPoint)
        self.checkBox_enableWindrose.stateChanged.connect(self.enableWindrose)
        #TODO disable model parameters when other than prentice sugita is selected, and enable load lookup if use lookup table is selected.
        self.button_box.accepted.connect(self.openRunDialog)
        self.radioButton_nestedMap.clicked.connect(self.enableNested)
        self.radioButton_simpleMap.clicked.connect(self.enableNested)
        self.spinBox_nestedArea.valueChanged.connect(self.checkNestedArea)
        self.spinBox_resolution.valueChanged.connect(self.checkNestedArea)
        self.spinBox_resNested.valueChanged.connect(self.checkNestedArea)

        # Events for Checklist
        self.mQgsFileWidget_startingPoint.fileChanged.connect(self.checkChecklist)
        self.mExtentGroupBox.extentChanged.connect(self.checkChecklist)
        self.spinBox_resolution.valueChanged.connect(self.checkChecklist)
        self.tableWidget_vector.itemSelectionChanged.connect(self.checkChecklist)
        self.tableWidget_raster.itemSelectionChanged.connect(self.checkChecklist)
        self.tableWidget_taxa.itemChanged.connect(self.checkChecklist)
        self.tableWidget_vegCom.itemChanged.connect(self.checkChecklist)
        self.pushButton_addSite.clicked.connect(self.checkChecklist)
        self.pushButton_removeSite.clicked.connect(self.checkChecklist)
        self.pushButton_importPollen.clicked.connect(self.checkChecklist)
        self.pushButton_removePollenFile.clicked.connect(self.checkChecklist)
        self.doubleSpin_atmosConstant.valueChanged.connect(self.checkChecklist)
        self.doubleSpin_diffConstant.valueChanged.connect(self.checkChecklist)
        self.doubleSpin_windSpeed.valueChanged.connect(self.checkChecklist)
        self.checkBox_enableWindrose.clicked.connect(self.checkChecklist)
        self.pushButton_addRule.clicked.connect(self.checkChecklist)
        self.pushButton_removeRule.clicked.connect(self.checkChecklist)
        self.pushButton_ruleBelow.clicked.connect(self.checkChecklist)
        self.pushButton_deleteBranch.clicked.connect(self.checkChecklist)
        self.spinBox_iter.valueChanged.connect(self.checkChecklist)
        self.lineEdit_author.textChanged.connect(self.checkChecklist)
        self.lineEdit_projectName.textChanged.connect(self.checkChecklist)
        self.plainTextEdit_description.textChanged.connect(self.checkChecklist)
        self.plainTextEdit_notes.textChanged.connect(self.checkChecklist)
        self.radioButton_nestedMap.clicked.connect(self.checkChecklist)
        self.radioButton_simpleMap.clicked.connect(self.checkChecklist)
        self.spinBox_nestedArea.valueChanged.connect(self.checkChecklist)
        self.spinBox_resolution.valueChanged.connect(self.checkChecklist)
        self.spinBox_resNested.valueChanged.connect(self.checkChecklist)
        self.radioButton_createMap.clicked.connect(self.checkChecklist)
        self.radioButton_loadPointMap.clicked.connect(self.checkChecklist)
        self.radioButton_loadBaseMap.clicked.connect(self.checkChecklist)
        self.radioButton_keepFitted.clicked.connect(self.checkChecklist)
        self.radioButton_keepTwo.clicked.connect(self.checkChecklist)
        self.radioButton_keepAll.clicked.connect(self.checkChecklist)
        self.doubleSpinBox_fit.valueChanged.connect(self.checkChecklist)
        self.doubleSpinBox_cumulFit.valueChanged.connect(self.checkChecklist)
        self.tableWidget_sites.itemChanged.connect(self.checkChecklist)
        self.spinBox_iter.valueChanged.connect(self.checkChecklist)

### DIRECTLY DIALOG RELATED FUNCTIONS
    def openRunDialog(self):
        """Opens a dialog that asks the user how they would like to run the plugin, with 3 options:
        1: Run only to create the point layer with environmental variables
        2: Run only to create the basemap
        3: Run full MSA model.

        :params from UI: none

        :class params: self.check_state, self.runDialog, self.accept"""
        if self.check_state == -1:
            iface.messageBar().pushMessage('Input incomplete', level=1)
            return
        input_state = 0
        if self.radioButton_loadPointMap.isChecked():
            input_state = 1
            if self.check_state == 1:  #cannot make a point map if the input is a loaded point map, not enough input for basemap or MSA
                iface.messageBar().pushMessage('Input incomplete, point-sampled map as input for point-sampled map', level=1)
                return #TODO this should become possible where the input map is not yet point_sampled, for differently shaped grids.
        elif self.radioButton_loadBaseMap.isChecked():
            input_state = 2
            if self.check_state == 0 or self.check_state == 1:  # cannot make point or basemap if input is a basemap, not enough input for msa
                iface.messageBar().pushMessage('Input incomplete, basemap as input for basemap', level=1)
                return

        self.runDialog = MsaQgisRunDialog(self.check_state, input_state)
        self.runDialog.show()

        # run MsaQgisDialog as well once the run dialog is accepted
        self.runDialog.accepted.connect(lambda: self.copyRunTypeAndSaveDir(self.runDialog)) # copy run_type from runDialog
        self.runDialog.accepted.connect(self.accept)

    def copyRunTypeAndSaveDir(self, runDialog):
        """Exists for the purpose of copying the runtype from the runDialog to the main Dialog

        :param runDialog: instance of a MsaQgisRunDialog
        :type runDialog: MsaQgisRunDialog"""
        self.run_type = runDialog.run_type
        self.save_directory = runDialog.mQgsFileWidget.filePath()

    def closeAll(self):
        """Closes all associated windows when main dialog is closed, if they are still open.

        :params from UI files: None
        :class params: self.veg_com_popup, self.taxonPopup, self.popup_rule_list, self. popup_save_file, self. popup_load_file"""
        try: self.veg_com_popup.close()
        except: pass
        try:self.taxonPopup.close()
        except: pass
        try: self.popup_rule_list.close()
        except: pass
        try: self.add_rule_popup.close()
        except: pass
        try: self.popup_save_file.close()
        except: pass
        try: self.popup_load_file.close()
        except: pass
        pass

    def changeStartingPoint(self):
        """Sets up the spatial and environmental input tab to show/hide which parts are necessary

        :params from UI files:

        """
        if self.radioButton_createMap.isChecked():
            #show labels
            self.label_areaOfInterest.show()
            self.label_resolution.show()
            self.label_fieldsAndBands.show()
            self.label_currentSel.show()
            self.label_vector.show()
            self.label_raster.show()
            #hide labels
            self.label_mapFile.hide()
            #show items
            self.mExtentGroupBox.show()
            self.spinBox_resolution.show()
            self.tableWidget_vector.show()
            self.tableWidget_raster.show()
            self.tableWidget_selected.show()
            self.tableWidget_selRaster.show()
            if self.radioButton_nestedMap.isChecked():
                self.label_resNested.show()
                self.label_nestedArea.show()
                self.spinBox_resNested.show()
                self.spinBox_nestedArea.show()
            #hide widgets
            self.mQgsFileWidget_startingPoint.hide()
            #change radiobutton text
            self.radioButton_nestedMap.setText('Nested')
        elif self.radioButton_loadPointMap.isChecked():
            #show labels

            self.label_mapFile.show()
            #hide labels
            self.label_fieldsAndBands.hide()
            self.label_currentSel.hide()
            self.label_areaOfInterest.hide()
            self.label_resolution.hide()
            self.label_vector.hide()
            self.label_raster.hide()
            self.label_resNested.hide()
            self.label_nestedArea.hide()
            #show widgets

            self.mQgsFileWidget_startingPoint.show()
            #hide widgets
            self.spinBox_resNested.hide()
            self.spinBox_nestedArea.hide()
            self.tableWidget_vector.hide()
            self.tableWidget_raster.hide()
            self.tableWidget_selected.hide()
            self.tableWidget_selRaster.hide()
            self.mExtentGroupBox.hide()
            self.spinBox_resolution.hide()
            #change radiobutton text
            self.radioButton_nestedMap.setText('Nested/Variable')

        elif self.radioButton_loadBaseMap.isChecked():
            #show labels
            self.label_mapFile.show()
            #hide labels
            self.label_areaOfInterest.hide()
            self.label_resolution.hide()
            self.label_fieldsAndBands.hide()
            self.label_currentSel.hide()
            self.label_vector.hide()
            self.label_raster.hide()

            self.label_resNested.hide()
            self.label_nestedArea.hide()
            #show widgets
            self.mQgsFileWidget_startingPoint.show()
            #hide widgets
            self.spinBox_resNested.hide()
            self.spinBox_nestedArea.hide()
            self.mExtentGroupBox.hide()
            self.spinBox_resolution.hide()
            self.tableWidget_vector.hide()
            self.tableWidget_raster.hide()
            self.tableWidget_selected.hide()
            self.tableWidget_selRaster.hide()
            #change radiobutton text
            self.radioButton_nestedMap.setText('Nested/Variable')


    def checkChecklist(self):
        """ Determines whether widgets have been filled by the user and checks the appropriate boxes if it has. Also
        changes the text of the status label based on which boxes are checked, to say which actions the user is able
        to undertake if they choose to run the programme. The checkboxes are checked at the absolute minimum of what is
        required to run (e.g. only one rule) and so are not an indication of whether the input is correct or sensible.

        :params from UI files:
        """
        # Extent set?
        if self.mExtentGroupBox.currentExtent() != QgsRectangle(0.0, 0.0):
            self.checkBox_extent.setChecked(True)
        elif self.radioButton_createMap.isChecked() == False and self.mQgsFileWidget_startingPoint.filePath() != '':
            self.checkBox_extent.setChecked(True)
        else:
            self.checkBox_extent.setChecked(False)

        # Resolution set?
        if self.radioButton_createMap.isChecked() == False and self.mQgsFileWidget_startingPoint.filePath() != '':
            self.checkBox_resolution.setChecked(True)
        elif self.radioButton_simpleMap.isChecked() and self.spinBox_resolution.value() != 0:
            self.checkBox_resolution.setChecked(True)
        elif self.radioButton_nestedMap.isChecked():
            if self.spinBox_resolution.value() != 0 and self.spinBox_resNested.value() != 0 and \
                self.spinBox_nestedArea.value() != 0:
                if self.spinBox_nestedArea.value() % self.spinBox_resNested.value() == 0 and \
                        self.spinBox_nestedArea.value() % self.spinBox_resolution.value() == 0 and \
                        self.spinBox_resolution.value()> self.spinBox_resNested.value():
                    self.checkBox_resolution.setChecked(True)
                else:
                    self.checkBox_resolution.setChecked(False)

            else:
                self.checkBox_resolution.setChecked(False)
        else:
            self.checkBox_resolution.setChecked(False)

        # Environmental variables selected?
        if self.tableWidget_selected.rowCount() != 0:
            self.checkBox_envLayers.setChecked(True)
        elif self.tableWidget_selRaster.rowCount() != 0:
            self.checkBox_envLayers.setChecked(True)
        else:
            self.checkBox_envLayers.setChecked(False)
        # Taxa set?
        if self.tableWidget_taxa.rowCount() != 0:
            self.checkBox_taxa.setChecked(True)
        else:
            self.checkBox_taxa.setChecked(False)
        # Vegetation communities set?
        if self.tableWidget_vegCom.rowCount() != 0:
            self.checkBox_vegCom.setChecked(True)
        else:
            self.checkBox_vegCom.setChecked(False)
        # Pollen counts set?
        if self.tableWidget_sites.rowCount() != 0:
            for row in range(self.tableWidget_sites.rowCount()):
                site_name = self.tableWidget_sites.item(row,0).text()
                check_state = False
                for row2 in range(self.tableWidget_pollenFile.rowCount()):
                    if self.tableWidget_pollenFile.item(row2, 0).text() == site_name:
                        check_state = True
                if check_state == False:
                    self.checkBox_pollenCounts.setChecked(False)
                    break
                else:
                    self.checkBox_pollenCounts.setChecked(True)

        else:
            self.checkBox_pollenCounts.setChecked(False)
        # Model Parameters set?
        if self.comboBox_dispModel.currentText() == 'HUMPOL mire model':
            if self.doubleSpin_atmosConstant.value() != 0 and self.doubleSpin_diffConstant.value() != 0 and self.doubleSpin_windSpeed.value() !=0:
                self.checkBox_parameters.setChecked(True)
            else:
                self.checkBox_parameters.setChecked(False)
        elif self.comboBox_dispModel.currentText() == 'different model': # TODO Fill here when adding new model
            #...
            pass
        else:
            self.checkBox_parameters.setChecked(False)
        # Windrose set?
        if self.checkBox_enableWindrose.isChecked:
            self.checkBox_windRose.setChecked(True)
        else:
            self.checkBox_windRose.setChecked(False)
        # Rules set?
        if self.listWidget_rules.count() != 0:
            self.checkBox_rules.setChecked(True)
        else:
            self.checkBox_rules.setChecked(False)
        # Rule Tree set?
        if self.dict_ruleTreeWidgets != {}:
            self.checkBox_ruleTree.setChecked(True)
        else:
            self.checkBox_ruleTree.setChecked(False)
        # Iterations set?
        if self.spinBox_iter.value() != 0:
            self.checkBox_iterations.setChecked(True)
        else:
            self.checkBox_iterations.setChecked(False)
        # Sampling sites set?
        if self.tableWidget_sites.rowCount() != 0:
            self.checkBox_samplingSites.setChecked(True)
        else:
            self.checkBox_samplingSites.setChecked(False)
        # Fit set?
        if self.doubleSpinBox_fit.value() != 0 or self.doubleSpinBox_cumulFit.value() != 0:
            self.checkBox_fit.setChecked(True)
        else:
            self.checkBox_fit.setChecked(False)
        # Data to Keep set?
        if self.radioButton_keepFitted.isChecked() or \
            self.radioButton_keepTwo.isChecked() or self.radioButton_keepAll.isChecked():
            self.checkBox_dataToKeep.setChecked(True)
        else:
            self.checkBox_dataToKeep.setChecked(False)
        # Pollen counts set?


        # Check which boxes have been checked or not to set the check state
        if (self.checkBox_extent.isChecked() and self.checkBox_resolution.isChecked()
                and self. checkBox_envLayers.isChecked()):
            self.check_state = 0
            if (self.checkBox_taxa.isChecked() and self.checkBox_vegCom.isChecked() and self.checkBox_rules.isChecked()
                    and self.checkBox_ruleTree.isChecked()):
                if self.dict_ruleTreeWidgets[1].isBaseGroup:  # Check if at least one base group rule
                    self.check_state = 1
                if (self.checkBox_samplingSites.isChecked() and self.checkBox_iterations.isChecked() and
                        self.checkBox_parameters.isChecked()):
                    self.check_state = 2
                #  note that existence of a base group is not a requirement for a full run
                    if (self.checkBox_pollenCounts.isChecked() and self.checkBox_dataToKeep.isChecked() and
                            self.checkBox_fit.isChecked()):
                        self.check_state = 3
        else:
            self.check_state = -1

    def enableWindrose(self):
        """Hides or shows the windrose input labels and spinboxes

        :params from UI files:self.label_north, self.label_northEast, self.label_east, self.label_southEast,
        self.label_south, self.label_southWest, self.label_west, self.label_northWest, self.doubleSpin_north,
        self.doubleSpin_northEast, self.doubleSpin_east, self.doubleSpin_southEast, self.doubleSpin_south,
        elf.doubleSpin_southWest, self.doubleSpin_west, self.doubleSpin_northWest, self.checkBox_enableWindrose"""

        if self.checkBox_enableWindrose.isChecked():
            self.label_north.show()
            self.label_northEast.show()
            self.label_east.show()
            self.label_southEast.show()
            self.label_south.show()
            self.label_southWest.show()
            self.label_west.show()
            self.label_northWest.show()
            self.doubleSpin_north.show()
            self.doubleSpin_northEast.show()
            self.doubleSpin_east.show()
            self.doubleSpin_southEast.show()
            self.doubleSpin_south.show()
            self.doubleSpin_southWest.show()
            self.doubleSpin_west.show()
            self.doubleSpin_northWest.show()
        elif self.checkBox_enableWindrose.isChecked() == False:
            self.label_north.hide()
            self.label_northEast.hide()
            self.label_east.hide()
            self.label_southEast.hide()
            self.label_south.hide()
            self.label_southWest.hide()
            self.label_west.hide()
            self.label_northWest.hide()
            self.doubleSpin_north.hide()
            self.doubleSpin_northEast.hide()
            self.doubleSpin_east.hide()
            self.doubleSpin_southEast.hide()
            self.doubleSpin_south.hide()
            self.doubleSpin_southWest.hide()
            self.doubleSpin_west.hide()
            self.doubleSpin_northWest.hide()
        else:
            pass

    def changeAtmosConstantValue(self):
        """ Changes the atmospheric constant value based on the value the user has given for the turbulence constant

        :params from UI files: self.label_calculatedTurbConst, self.doubleSpin_atmosConstant """

        self.label_calculatedTurbConst.setText(str(self.doubleSpin_atmosConstant.value()*0.5))

    def getFieldsandBands(self, tableWidget_vector, tableWidget_raster):
        """Fills two table widgets with all fields from vector polygon layers and all bands from raster layers that are
        currently loaded into the QGIS interface.

        :param tableWidget_raster: Table that will contain the raster layers
        :type tableWidget_raster: QTableWidget

        :param tableWidget_vector: Table that will containg the vector layers
        :type tableWidget_vector: QTableWidget"""
        # Make sure the tables are clear first
        tableWidget_vector.clear()
        row_count = 0
        column_count = 0
        tableWidget_vector.setRowCount(row_count + 1)

        tableWidget_raster.clear()
        ras_row_count = 0
        ras_column_count = 0
        tableWidget_raster.setRowCount(ras_row_count + 1)

        # Fill tables
        for lyr_nr in range(iface.mapCanvas().layerCount()):
            layer = iface.mapCanvas().layer(lyr_nr)
            if (layer.type() == layer.VectorLayer) and (layer.geometryType() == QgsWkbTypes.PolygonGeometry):
                data_provider = layer.dataProvider()
                for field in data_provider.fields():
                    tableWidget_vector.setItem(row_count, column_count, QTableWidgetItem(layer.name()))
                    tableWidget_vector.setItem(row_count, column_count+1, QTableWidgetItem(field.name()))
                    row_count += 1
                    tableWidget_vector.setRowCount(row_count + 1)
            elif layer.type() == layer.RasterLayer:
                for band in range(layer.bandCount()):
                    tableWidget_raster.setItem(ras_row_count, ras_column_count, QTableWidgetItem(layer.name()))
                    tableWidget_raster.setItem(ras_row_count, ras_column_count+1, QTableWidgetItem(layer.bandName(band + 1)))
                    ras_row_count += 1
                    tableWidget_raster.setRowCount(ras_row_count + 1)
            else:
                continue
            tableWidget_vector.setHorizontalHeaderLabels(['Layers', 'Fields'])
            tableWidget_raster.setHorizontalHeaderLabels(['Layers', 'Bands'])
        #remove the extra generated row when everything is done.
        tableWidget_vector.setRowCount(row_count)
        tableWidget_raster.setRowCount(ras_row_count)

    def updateSelectedRows(self, tableWidget_selection, tableWidget_list):
        """ Updates a table widget with the information from rows selected in another table widget

        :param tableWidget_selection: Table the selected information will be copied to
        :type tableWidget_selection: QTableWidget

        :param tableWidget_list: Table in which the selection is made that will be copied
        :type tableWidget_list: QTableWidget
        """
        tableWidget_selection.setRowCount(len(tableWidget_list.selectionModel().selectedRows()))
        row_count_sel = 0

        for row in range(tableWidget_list.rowCount()):
            if tableWidget_list.item(row, 0).isSelected():
                tableWidget_selection.setItem(row_count_sel,
                                              0,
                                              QTableWidgetItem(tableWidget_list.item(row, 0)))
                tableWidget_selection.setItem(row_count_sel,
                                              1,
                                              QTableWidgetItem(tableWidget_list.item(row, 1)))
            else:
                continue
            row_count_sel += 1
### SAVING AND LOADING RELATED FUNCTIONS
    def loadHandbagFile(self):
        """
        Loads a HUMPOL handbag (.hum) file into the software. This fills in the data (if specified in the file) for:
        Taxa
        Communities
        Sample points
        Windroses
        Metadata
        Notes
        Compatible with the HUMPOL suite (Bunting & Middleton 2005) and LandPolFlow (Bunting & Middleton 2009)

        :params from UI files: self.qgsFileWidget_importHandbag,  self.tableWidget_vegCom, self.tableWidget_taxa,
        self.tableWidget_vegCom, ETC

        """
        #TODO windrose data, metadata, notes
        file_name = self.qgsFileWidget_importHandbag.filePath()
        if not os.path.isfile(file_name):
            iface.messageBar().pushMessage('File does not exist, please try again', level=1)
        else:
            with open(file_name) as file:
                for line in file:
                    if line[0] == '1':  # Taxa
                        if int(line[:4]) >= 1100:
                            line = line[5:]
                            line_list = list(re.split('\t|\n', line))
                            row_count = self.tableWidget_taxa.rowCount()
                            self.tableWidget_taxa.setRowCount(row_count + 1)
                            self.tableWidget_taxa.setItem(row_count, 0, QTableWidgetItem(line_list[0]))
                            self.tableWidget_taxa.setItem(row_count, 1, QTableWidgetItem(line_list[1]))
                            self.tableWidget_taxa.setItem(row_count, 2, QTableWidgetItem(str(line_list[2])))
                            self.tableWidget_taxa.setItem(row_count, 3, QTableWidgetItem(str(line_list[3])))
                    elif line[0] == '2':  # Communities
                        # Skip community names (TODO but what to do if a handbag file has multiple community files?)
                        if 2200 <= int(line[:4]) < 2300:
                            line = line[7:]
                            line = line.replace('\n','')
                            self.tableWidget_vegCom.setRowCount(self.tableWidget_vegCom.rowCount() +1)
                            self.tableWidget_vegCom.setItem(self.tableWidget_vegCom.rowCount() - 1, 0, QTableWidgetItem(
                                line))
                        elif int(line[:4]) >= 2300:
                            line = line[5:]
                            line_list = list(re.split('\t|\n', line))
                            # Only create a new column if the header does not yet exist note: this is a duplicate from addNewVegCom
                            header_list = [self.tableWidget_vegCom.horizontalHeaderItem(column).text() for column in
                                           range(1, self.tableWidget_vegCom.columnCount())]
                            if line_list[0] in header_list:
                                # Get column number of named column
                                for column in range(self.tableWidget_vegCom.columnCount()):
                                    header_text = self.tableWidget_vegCom.horizontalHeaderItem(column).text()
                                    if header_text == line_list[0]:
                                        self.tableWidget_vegCom.setItem(self.tableWidget_vegCom.rowCount() - 1, column,
                                                                   QTableWidgetItem(line_list[1]))
                                # Add value at right location to that column
                                pass
                            elif line_list[0] not in header_list:
                                self.tableWidget_vegCom.setColumnCount(self.tableWidget_vegCom.columnCount()+1)
                                # Set header of new column
                                self.tableWidget_vegCom.setHorizontalHeaderItem(self.tableWidget_vegCom.columnCount() - 1,
                                                                           QTableWidgetItem(line_list[0]))
                                # Add value to new column
                                self.tableWidget_vegCom.setItem(self.tableWidget_vegCom.rowCount() - 1, self.tableWidget_vegCom.columnCount() - 1,
                                                           QTableWidgetItem(
                                                               str(line_list[1])))
                            else:
                                iface.messageBar().pushMessage('Error in creating vegetation community columns', level=1)
                    elif line[0] == '3':  # Sample points
                        pass
                        #TODO
                file.close()

    def saveRuleDict(self, file_name_rule_dict):
        """ Pickles/serializes the rules dictionary for later retrieval"""
        with open(file_name_rule_dict,'wb') as pkl_file:
            pickle.dump(self.nest_dict_rules, pkl_file)

    def loadRuleDict(self,file_name_rule_dict):
        """ Loads the pickled dictionary of the nest_dict_rule"""
        with open (file_name_rule_dict, 'rb') as pkl_file:
            self.nest_dict_rules = pickle.load(pkl_file)
            self.listWidget_rules.clear()
            self.rule_number = 0
            for key in self.nest_dict_rules:
                self.listWidget_rules.addItem(self.nest_dict_rules[key][1])
                self.rule_number += 1

    def saveHandbagFile(self):
        """ Saves all of the input data that is backwards compatible with HUMPOL/LandPolFlow into a single text file (.hum)"""
        #TODO
        pass

    def saveRuleTree(self,  file_name_rule_tree):
        """ Pickles/serializes the dictionary containing all entries into the rule tree.
        Since QtWidgets cannot be pickled or saved, a dictionary is created that contains all the input required to
        rebuild it. Every entry contains information on a single ruleTreeWidget. The key is the ruleTreeWidget's order_id. """
        picklable_dict_ruleTreeWidgets = {}
        for key in self.dict_ruleTreeWidgets:
            list_ruleTreeWidgets_variables = []
            #append selected rule, next rule tree widgets, prev rule tree widgets, duplicate rule tree widgets, connection type, isbasegroup
            list_ruleTreeWidgets_variables.append(self.dict_ruleTreeWidgets[key].comboBox_name.currentText())
            list_ruleTreeWidgets_variables.append(self.dict_ruleTreeWidgets[key].connection_type)
            list_ruleTreeWidgets_variables.append(self.dict_ruleTreeWidgets[key].isBaseGroup)
            list_ruleTreeWidgets_variables.append(self.dict_ruleTreeWidgets[key].prev_ruleTreeWidgets)
            list_ruleTreeWidgets_variables.append(self.dict_ruleTreeWidgets[key].next_ruleTreeWidgets)
            list_ruleTreeWidgets_variables.append(self.dict_ruleTreeWidgets[key].duplicate_ruleTreeWidgets)
            picklable_dict_ruleTreeWidgets[key] = list_ruleTreeWidgets_variables
        with open (file_name_rule_tree, 'wb') as pkl_file:
            pickle.dump(picklable_dict_ruleTreeWidgets, pkl_file)

    def loadRuleTree(self, file_name_rule_tree):
        """ Imports the pickled dictionary of the rule tree. """
        with open (file_name_rule_tree, 'rb') as pkl_file:
            pickleable_dict_ruleTreeWidgets = pickle.load(pkl_file)

        #Empty the layout and dict
        self.clearLayout(self.ruleTreeLayout)
        self.dict_ruleTreeWidgets = {}


        #reconstruct the rule tree and ruletreedict
        x_position_for_spoilerplate = self.scrollArea_ruleTree.x() + self.tab_top.x() + self.x()
        y_position_for_spoilerplate = self.scrollArea_ruleTree.y() + self.tab_top.y() + self.y()
        for key in pickleable_dict_ruleTreeWidgets:
            #build upper rule tree widget
            if key == 1:
                next_layout = QHBoxLayout()
                ruleTreeWidget_base = RuleTreeWidget(self.nest_dict_rules, key, next_layout, None,
                                                     pickleable_dict_ruleTreeWidgets[key][1],
                                                     main_dialog_x=x_position_for_spoilerplate, main_dialog_y=y_position_for_spoilerplate)
                ruleTreeWidget_base.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3] # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                ruleTreeWidget_base.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                ruleTreeWidget_base.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                #place widget
                self.ruleTreeLayout.insertWidget(0, ruleTreeWidget_base)
                self.ruleTreeLayout.insertLayout(1, ruleTreeWidget_base.next_layout)
                self.ruleTreeLayout.insertStretch(2, 1)
                #add to dictionary
                self.dict_ruleTreeWidgets[key] = ruleTreeWidget_base
                #set basegroup and selected rule
                if pickleable_dict_ruleTreeWidgets[key][2]:
                    ruleTreeWidget_base.isSelected = True
                    ruleTreeWidget_base.toggleBaseGroup()
                    ruleTreeWidget_base.isSelected = False
                self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(pickleable_dict_ruleTreeWidgets[key][0])
                #make selectable
                ruleTreeWidget_base.clicked.connect(
                    lambda *args, ruleTreeWidget_id=ruleTreeWidget_base.order_id, ruleTreeWidget=ruleTreeWidget_base:
                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
            if key >1:
                #check if rule is a duplicate
                if pickleable_dict_ruleTreeWidgets[key][5]:
                    if min(pickleable_dict_ruleTreeWidgets[key][5]) > key:#is the main duplicate, add to UI
                        #check connection type
                        if pickleable_dict_ruleTreeWidgets[key][1] == 'normal':
                            previous_id = max(pickleable_dict_ruleTreeWidgets[key][3])
                            next_layout = QHBoxLayout()
                            own_layout = QVBoxLayout()
                            ruleTreeWidget_normal = RuleTreeWidget(self.nest_dict_rules, key, next_layout, own_layout,
                                                                   pickleable_dict_ruleTreeWidgets[key][1],
                                                                   main_dialog_x=x_position_for_spoilerplate,
                                                                   main_dialog_y=y_position_for_spoilerplate)
                            ruleTreeWidget_normal.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][
                                3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                            ruleTreeWidget_normal.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                            ruleTreeWidget_normal.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                            # place widget
                            # check if this widget follows directly from a widget in series # Todo this would never happen and should be under the version that deals with duplicates
                            if self.dict_ruleTreeWidgets[previous_id].connection_type == 'series':
                                self.dict_ruleTreeWidgets[previous_id].next_layout.addWidget(ruleTreeWidget_normal)
                                self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(
                                    ruleTreeWidget_normal.next_layout)
                                ruleTreeWidget_normal.own_layout = []
                                pass
                            else:
                                self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(own_layout)
                                own_layout.addWidget(ruleTreeWidget_normal)
                                own_layout.addLayout(next_layout)
                                own_layout.addStretch()
                            # add to dictionary
                            self.dict_ruleTreeWidgets[key] = ruleTreeWidget_normal
                            # set basegroup and selected rule
                            if pickleable_dict_ruleTreeWidgets[key][2]:
                                ruleTreeWidget_normal.isSelected = True
                                ruleTreeWidget_normal.toggleBaseGroup()
                                ruleTreeWidget_normal.isSelected = False
                            self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(
                                pickleable_dict_ruleTreeWidgets[key][0])
                            ruleTreeWidget_normal.clicked.connect(
                                lambda *args, ruleTreeWidget_id=ruleTreeWidget_normal.order_id,
                                       ruleTreeWidget=ruleTreeWidget_normal:
                                self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
                        elif pickleable_dict_ruleTreeWidgets[key][1] == 'series start':
                            if min(pickleable_dict_ruleTreeWidgets[key][5]) > key:  # is the main duplicate, add to UI
                                next_layout = QVBoxLayout()
                                own_layout = QVBoxLayout()
                                ruleTreeWidget_start = RuleTreeWidget(self.nest_dict_rules, key, next_layout,
                                                                      own_layout,
                                                                      pickleable_dict_ruleTreeWidgets[key][1],
                                                                      main_dialog_x=x_position_for_spoilerplate,
                                                                      main_dialog_y=y_position_for_spoilerplate)
                                ruleTreeWidget_start.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                                ruleTreeWidget_start.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                                ruleTreeWidget_start.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                                # place widget
                                previous_id = max(ruleTreeWidget_start.prev_ruleTreeWidgets)
                                self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(
                                    ruleTreeWidget_start.own_layout)
                                ruleTreeWidget_start.own_layout.addWidget(ruleTreeWidget_start)
                                ruleTreeWidget_start.own_layout.addLayout(ruleTreeWidget_start.next_layout)

                                # add to dictionary
                                self.dict_ruleTreeWidgets[key] = ruleTreeWidget_start
                                # set basegroup and selected rule
                                self.dict_ruleTreeWidgets[key].isBaseGroup = pickleable_dict_ruleTreeWidgets[key][2]
                                self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(
                                    pickleable_dict_ruleTreeWidgets[key][0])
                                # connect to selection
                                ruleTreeWidget_start.clicked.connect(
                                    lambda *args, ruleTreeWidget_id=ruleTreeWidget_start.order_id,
                                           ruleTreeWidget=ruleTreeWidget_start:
                                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))

                        elif pickleable_dict_ruleTreeWidgets[key][1] == 'series':
                            if min(pickleable_dict_ruleTreeWidgets[key][5]) > key:  # is the main duplicate, add to UI
                                # layouts
                                next_layout = QVBoxLayout()
                                own_layout = QHBoxLayout()
                                # create widget
                                ruleTreeWidget_series = RuleTreeWidget(self.nest_dict_rules, key, next_layout,
                                                                       own_layout,
                                                                       pickleable_dict_ruleTreeWidgets[key][1],
                                                                       main_dialog_x=x_position_for_spoilerplate,
                                                                       main_dialog_y=y_position_for_spoilerplate)
                                ruleTreeWidget_series.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                                ruleTreeWidget_series.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                                ruleTreeWidget_series.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                                # place widget
                                # find which layout it should be added to, either its own in case the previous widget was series top, or to the series layout if previous is series
                                list_prev_widgets = []
                                if str(key)[-1] == '0':
                                    key_without_last_0 = str(key)[:len(str(key)) - 1]
                                else:
                                    key_without_last_0 = False
                                for id in reversed(ruleTreeWidget_series.prev_ruleTreeWidgets):
                                    if str(id)[-1] == '0' or str(id) == key_without_last_0 or id == 1:
                                        list_prev_widgets.append(id)
                                previous_id = max(list_prev_widgets)
                                if self.dict_ruleTreeWidgets[previous_id].connection_type == 'series start':
                                    self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(own_layout)
                                    self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(
                                        ruleTreeWidget_series.next_layout)
                                    ruleTreeWidget_series.own_layout.addWidget(ruleTreeWidget_series)
                                    ruleTreeWidget_series.own_layout.addStretch()
                                elif self.dict_ruleTreeWidgets[previous_id].connection_type == 'series':
                                    ruleTreeWidget_series.own_layout = self.dict_ruleTreeWidgets[previous_id].own_layout
                                    ruleTreeWidget_series.next_layout = self.dict_ruleTreeWidgets[previous_id].next_layout
                                    self.dict_ruleTreeWidgets[previous_id].own_layout.addWidget(ruleTreeWidget_series)
                                    self.dict_ruleTreeWidgets[previous_id].own_layout.addStretch()


                                # add to dictionary
                                self.dict_ruleTreeWidgets[key] = ruleTreeWidget_series

                                # set basegroup and selected rule
                                self.dict_ruleTreeWidgets[key].isBaseGroup = pickleable_dict_ruleTreeWidgets[key][2]
                                self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(
                                    pickleable_dict_ruleTreeWidgets[key][0])
                                # connect to selection
                                ruleTreeWidget_series.clicked.connect(
                                    lambda *args, ruleTreeWidget_id=ruleTreeWidget_series.order_id,
                                           ruleTreeWidget=ruleTreeWidget_series:
                                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))

                    else: # is not the main duplicate. Create but do not add to UI

                        ruleTreeWidget_duplicate = RuleTreeWidget(self.nest_dict_rules,key,None,None,
                                                                  pickleable_dict_ruleTreeWidgets[key][1])
                        ruleTreeWidget_duplicate.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                        ruleTreeWidget_duplicate.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                        ruleTreeWidget_duplicate.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                        #add to dictionary
                        self.dict_ruleTreeWidgets[key] = ruleTreeWidget_duplicate
                        continue
                else: #is not a duplicate, add to UI
                    if pickleable_dict_ruleTreeWidgets[key][1] == 'normal':
                        previous_id = max(pickleable_dict_ruleTreeWidgets[key][3])
                        next_layout = QHBoxLayout()
                        own_layout = QVBoxLayout()
                        ruleTreeWidget_normal = RuleTreeWidget(self.nest_dict_rules, key, next_layout, own_layout,
                                                               pickleable_dict_ruleTreeWidgets[key][1],
                                                               main_dialog_x=x_position_for_spoilerplate,
                                                               main_dialog_y=y_position_for_spoilerplate)
                        ruleTreeWidget_normal.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                        ruleTreeWidget_normal.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                        ruleTreeWidget_normal.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                        # place widget
                        self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(own_layout)
                        own_layout.addWidget(ruleTreeWidget_normal)
                        own_layout.addLayout(next_layout)
                        own_layout.addStretch()
                        # add to dictionary
                        self.dict_ruleTreeWidgets[key] = ruleTreeWidget_normal
                        # set basegroup and selected rule
                        if pickleable_dict_ruleTreeWidgets[key][2]:
                            ruleTreeWidget_normal.isSelected = True
                            ruleTreeWidget_normal.toggleBaseGroup()
                            ruleTreeWidget_normal.isSelected = False
                        self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(
                            pickleable_dict_ruleTreeWidgets[key][0])
                        ruleTreeWidget_normal.clicked.connect(
                            lambda *args, ruleTreeWidget_id=ruleTreeWidget_normal.order_id,
                                   ruleTreeWidget=ruleTreeWidget_normal:
                            self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))

                    elif pickleable_dict_ruleTreeWidgets[key][1] == 'series start':
                        next_layout = QVBoxLayout()
                        own_layout = QVBoxLayout()
                        ruleTreeWidget_start = RuleTreeWidget(self.nest_dict_rules, key, next_layout, own_layout,
                                                               pickleable_dict_ruleTreeWidgets[key][1],
                                                               main_dialog_x=x_position_for_spoilerplate,
                                                               main_dialog_y=y_position_for_spoilerplate)
                        ruleTreeWidget_start.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                        ruleTreeWidget_start.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                        ruleTreeWidget_start.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                        # place widget
                        previous_id = max(ruleTreeWidget_start.prev_ruleTreeWidgets)
                        self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(ruleTreeWidget_start.own_layout)
                        ruleTreeWidget_start.own_layout.addWidget(ruleTreeWidget_start)
                        ruleTreeWidget_start.own_layout.addLayout(ruleTreeWidget_start.next_layout)

                        # add to dictionary
                        self.dict_ruleTreeWidgets[key] = ruleTreeWidget_start
                        # set basegroup and selected rule
                        self.dict_ruleTreeWidgets[key].isBaseGroup = pickleable_dict_ruleTreeWidgets[key][2]
                        self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(
                            pickleable_dict_ruleTreeWidgets[key][0])
                        #connect to selection
                        ruleTreeWidget_start.clicked.connect(
                            lambda *args, ruleTreeWidget_id=ruleTreeWidget_start.order_id,
                                   ruleTreeWidget=ruleTreeWidget_start:
                            self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))

                    elif pickleable_dict_ruleTreeWidgets[key][1] == 'series':
                        #layouts
                        next_layout = QVBoxLayout()
                        own_layout = QHBoxLayout()
                        #create widget
                        ruleTreeWidget_series = RuleTreeWidget(self.nest_dict_rules, key, next_layout, own_layout,
                                                               pickleable_dict_ruleTreeWidgets[key][1],
                                                               main_dialog_x=x_position_for_spoilerplate,
                                                               main_dialog_y=y_position_for_spoilerplate)
                        ruleTreeWidget_series.prev_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][3]  # TODO no idea why I couldn't just give these in the constructor, it's being difficult. For now, this works
                        ruleTreeWidget_series.next_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][4]
                        ruleTreeWidget_series.duplicate_ruleTreeWidgets = pickleable_dict_ruleTreeWidgets[key][5]
                        #place widget
                        #find which layout it should be added to, either its own in case the previous widget was series top, or to the series layout if previous is series
                        list_prev_widgets = []
                        if str(key)[-1] == '0':
                            key_without_last_0 = str(key)[:len(str(key))-1]
                        else:
                            key_without_last_0 = False
                        for id in reversed(ruleTreeWidget_series.prev_ruleTreeWidgets):
                            if str(id)[-1] == '0' or str(id) == key_without_last_0 or id == 1:
                                list_prev_widgets.append(id)
                        previous_id = max(list_prev_widgets)
                        if self.dict_ruleTreeWidgets[previous_id].connection_type == 'series start':
                            self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(own_layout)
                            self.dict_ruleTreeWidgets[previous_id].next_layout.addLayout(ruleTreeWidget_series.next_layout)
                            ruleTreeWidget_series.own_layout.addWidget(ruleTreeWidget_series)
                            ruleTreeWidget_series.own_layout.addStretch()
                        elif self.dict_ruleTreeWidgets[previous_id].connection_type == 'series':
                            ruleTreeWidget_series.own_layout = self.dict_ruleTreeWidgets[previous_id].own_layout
                            ruleTreeWidget_series.next_layout = self.dict_ruleTreeWidgets[previous_id].next_layout
                            self.dict_ruleTreeWidgets[previous_id].own_layout.addWidget(ruleTreeWidget_series)
                            self.dict_ruleTreeWidgets[previous_id].own_layout.addStretch()

                        #add to dictionary
                        self.dict_ruleTreeWidgets[key] = ruleTreeWidget_series

                        #set basegroup and selected rule
                        self.dict_ruleTreeWidgets[key].isBaseGroup = pickleable_dict_ruleTreeWidgets[key][2]
                        self.dict_ruleTreeWidgets[key].comboBox_name.setCurrentText(
                            pickleable_dict_ruleTreeWidgets[key][0])
                        #connect to selection
                        ruleTreeWidget_series.clicked.connect(
                            lambda *args, ruleTreeWidget_id=ruleTreeWidget_series.order_id,
                                   ruleTreeWidget=ruleTreeWidget_series:
                            self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
        # print(self.dict_ruleTreeWidgets)
        # for key in self.dict_ruleTreeWidgets:
        #     print('self ',key ,'prev ', self.dict_ruleTreeWidgets[key].prev_ruleTreeWidgets, ', next ',
        #           self.dict_ruleTreeWidgets[key].next_ruleTreeWidgets, ', duplicate ',
        #           self.dict_ruleTreeWidgets[key].duplicate_ruleTreeWidgets)

    def saveInput(self, file_name_input, directory_name):
        """ Saves all of the input data, including input that is NOT backwards compatible with HUMPOL/LandPolFlow into a single text file (.msa)"""
        ### write a .csv file with all the data
        with open(file_name_input, 'w', newline= '') as csv_file:
            iface.messageBar().pushMessage('Writing file', level=3)
            writer = csv.writer(csv_file)
            #metadata
            writer.writerow(['Metadata'])
            writer.writerow(['Save directory', directory_name])
            writer.writerow(['Project name', self.lineEdit_projectName.text()])
            writer.writerow(['Author(s)', self.lineEdit_author.text()])
            writer.writerow(['Description', self.plainTextEdit_description.toPlainText()])
            #saved settings
            writer.writerow(['Saved settings'])
            crs = QgsProject.instance().crs().authid()
            writer.writerow(['CRS', crs])
            if self.radioButton_loadPointMap.isChecked():
                writer.writerow(['Starting point', 'Load point map', self.mQgsFileWidget_startingPoint.filePath()])
            elif self.radioButton_loadBaseMap.isChecked():
                writer.writerow(['Starting point', 'Load basemap', self.mQgsFileWidget_startingPoint.filePath()])
            else:
                writer.writerow(['Starting point', 'Map from scratch', 'No file set'])
            if self.extent:
                x_min = self.extent.xMinimum()
                x_max = self.extent.xMaximum()
                y_min = self.extent.yMinimum()
                y_max = self.extent.yMaximum()
            else:
                x_min = 'No extent set'
                x_max = 'No extent set'
                y_min = 'No extent set'
                y_max = 'No extent set'
            writer.writerow(['x_min', x_min])
            writer.writerow(['x_max', x_max])
            writer.writerow(['y_min', y_min])
            writer.writerow(['y_max', y_max])
            if self.radioButton_simpleMap.isChecked():
                spacing = self.spinBox_resolution.value()
                writer.writerow(['Spacing', 'Simple', spacing, 'Spacing nested', 'Not set', 'Nested sides', 'Not set' ])
            elif self.radioButton_nestedMap.isChecked():
                spacing = self.spinBox_resolution.value()
                spacing_nested = self.spinBox_resNested.value()
                nested_sides = self.spinBox_nestedArea.value()
                writer.writerow(['Spacing', 'Nested', spacing, 'Spacing nested', spacing_nested, 'Nested sides', nested_sides ])

            n_of_iter = self.spinBox_iter.value()
            writer.writerow(['n of iterations',  n_of_iter])
            #model parameters
            dispersal_model = self.comboBox_dispModel.currentText()
            atmostpheric_constant = self.doubleSpin_atmosConstant.value()
            diffusion_constant = self.doubleSpin_diffConstant.value()
            windspeed = self.doubleSpin_windSpeed.value()
            windrose_enabled = self.checkBox_enableWindrose.isChecked()
            wr_north = self.doubleSpin_north.value()
            wr_northEast = self.doubleSpin_northEast.value()
            wr_east = self.doubleSpin_east.value()
            wr_southeast = self.doubleSpin_southEast.value()
            wr_south = self.doubleSpin_south.value()
            wr_southwest = self.doubleSpin_southWest.value()
            wr_west = self.doubleSpin_west.value()
            wr_northwest = self.doubleSpin_northWest.value()
            fit_model = self.comboBox_fit.currentText()
            fit_site = self.doubleSpinBox_fit.value()
            fit_cumul = self.doubleSpinBox_cumulFit.value()

            writer.writerow(['Model parameters'])

            writer.writerow(['dispersal model', dispersal_model]) ###TODO rest of model parameters
            writer.writerow(['atmospheric constant', atmostpheric_constant ])
            writer.writerow(['diffusion constant', diffusion_constant])
            writer.writerow(['windspeed', windspeed])
            writer.writerow(['Windrose enabled', windrose_enabled])
            if windrose_enabled:
                writer.writerow(['','north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'])
                writer.writerow(['windrose', wr_north, wr_northEast, wr_east, wr_southeast, wr_south, wr_southwest, wr_west, wr_northwest])
            writer.writerow(['','fit model', 'desired fit per site', 'desired cumulative fit'])
            writer.writerow(['fit', fit_model, fit_site, fit_cumul])
            if self.radioButton_keepFitted.isChecked():
                writer.writerow(['maps', 'Keep fitted'])
            elif self.radioButton_keepAll.isChecked():
                writer.writerow(['maps', 'Keep all + loadings'])
            elif self.radioButton_keepTwo.isChecked():
                writer.writerow(['maps', 'keep all - loadings'])


            #selected fields and bands
            writer.writerow(['selected fields'])
            for row in range(self.tableWidget_selected.rowCount()):
                writer.writerow(['field',row, self.tableWidget_selected.item(row, 0).text(), self.tableWidget_selected.item(row,1).text()])
            #selected bands
            writer.writerow(['selected bands'])
            for row in range(self.tableWidget_selRaster.rowCount()):
                writer.writerow(['band',row, self.tableWidget_selRaster.item(row, 0).text(), self.tableWidget_selRaster.item(row,1).text()])
            #taxa
            writer.writerow(['Taxa'])
            writer.writerow([None, 'row', 'short name', 'full name', 'fall speed', 'relative pollen productivity'])
            for row in range(self.tableWidget_taxa.rowCount()):
                writer.writerow(['taxon',row, self.tableWidget_taxa.item(row, 0).text(), self.tableWidget_taxa.item(row, 1).text(),
                                 self.tableWidget_taxa.item(row, 2).text(), self.tableWidget_taxa.item(row, 3).text()])
            #communities
            writer.writerow(['Communities'])
            list_veg_com_headers = ['community headers','row']
            for column in range (self.tableWidget_vegCom.columnCount()):
                list_veg_com_headers.append(self.tableWidget_vegCom.horizontalHeaderItem(column).text())
            writer.writerow(list_veg_com_headers)
            list_veg_com_species= []
            for row in range(self.tableWidget_vegCom.rowCount()):
                list_veg_com_species.append('community')
                list_veg_com_species.append(row)
                for column in range (self.tableWidget_vegCom.columnCount()):
                    if self.tableWidget_vegCom.item(row,column):
                        list_veg_com_species.append(self.tableWidget_vegCom.item(row,column).text())
                    else:
                        list_veg_com_species.append(None)
                writer.writerow(list_veg_com_species)
                list_veg_com_species = []
            #samples
            writer.writerow(['Sampling Sites'])
            list_samples_header= [None, 'site-name', 'sample_x', 'sample_y', 'Lake_or_point']
            writer.writerow(list_samples_header)
            for row in range(self.tableWidget_sites.rowCount()):
                list_samples =['sampling site', self.tableWidget_sites.item(row,0).text(), self.tableWidget_sites.item(row,1).text(), self.tableWidget_sites.item(row, 2).text(), self.tableWidget_sites.item(row, 3).text()]
                writer.writerow(list_samples)
            writer.writerow(['Sampling Paths'])
            list_samples_paths_headers = [None, 'site_name', 'file_path']
            writer.writerow(list_samples_paths_headers)
            for row in range(self.tableWidget_pollenFile.rowCount()):
                list_sample_file_path =['file path', self.tableWidget_pollenFile.item(row, 0).text(),  self.tableWidget_pollenFile.item(row,1).text()]
                writer.writerow(list_sample_file_path)
            #rules
            writer.writerow(['Rule list', 'not used in loading file, open pickled file instead'])
            for key in self.nest_dict_rules:
                writer.writerow([key, self.nest_dict_rules[key][1]])
            #order ids rule tree widget
            writer.writerow(['RuleTreeWidget order id list', 'not used in loading file, open pickled file instead'])
            for key in self.dict_ruleTreeWidgets:
                writer.writerow([key,self.dict_ruleTreeWidgets[key].connection_type,
                                 self.dict_ruleTreeWidgets[key].comboBox_name.currentText()])
            #changelog
            writer.writerow(['Changelog'])
            writer.writerow(['Changelog start'])
            for line in range(self.listWidget_changeLog.count()):
                writer.writerow(['changelog', self.listWidget_changeLog.item(line).text()])
            writer.writerow(['Changelog end'])
            #notes
            writer.writerow(['Notes:', self.plainTextEdit_notes.toPlainText()])

    def saveImageRuleTree(self,  file_name_input):
        """ Saves an image of the rule tree that can be used for reference outside of the programme. """
        file_name = file_name_input
        #TODO deselect any selected ruleTreeWidgets
        self.frame_ruleTree.grab().save(file_name)

    def loadInput(self, file_name_input):
        """ Loads the data stored in the inputstate.csv file into the UI.
        It reads the .csv line by line and checks what type data is contained in the inputstate file by reading the first
        entry in a row (row[0]) and fills the appropriate widget accordingly.
        This is a subfunction only to be called by loadFiles.
        file_name_input contains a URI for a directory, in which a file called inputstate.csv is stored"""
        file_name = file_name_input
        with open(file_name, 'r', newline= '') as csv_file:
            reader = csv.reader(csv_file)
            for row in reader:

                if row[0] == 'x_min':
                    x_min = float(row[1])
                elif row[0] == 'x_max':
                    x_max = float(row[1])
                elif row[0] == 'y_min':
                    y_min = float(row[1])
                elif row[0] == 'y_max':
                    y_max = float(row[1])
                elif row[0] == 'CRS':
                    crs_string = row[1]
                    crs= QgsCoordinateReferenceSystem(crs_string)
                elif row[0] == 'Starting Point':
                    if row[1] == 'map from scratch':
                        self.radioButton_createMap.setChecked(True)
                        self.changeStartingPoint()
                    elif row[1] == 'Load point map':
                        self.radioButton_loadPointMap.setChecked(True)
                        self.changeStartingPoint()
                        self.mQgsFileWidget_startingPoint.setFilePath(row[2])
                    elif row[1] == 'Load basemap':
                        self.radioButton_loadBaseMap.setChecked(True)
                        self.changeStartingPoint()
                        self.mQgsFileWidget_startingPoint.setFilePath(row[2])
                elif row[0] == 'Spacing':
                    if row[1] == 'Nested':
                        self.radioButton_nestedMap.setChecked(True)
                        self.enableNested()
                        self.spinBox_resolution.setValue(int(row[2]))
                        self.spinBox_resNested.setValue(int(row[4]))
                        self.spinBox_nestedArea.setValue(int(row[6]))
                    elif row[1] == 'Simple':
                        self.radioButton_simpleMap.setChecked(True)
                        self.enableNested()
                        self.spinBox_resolution.setValue(int(row[2]))
                elif row[0] == 'n of iterations':
                    self.spinBox_iter.setValue(int(row[1]))
                elif row[0] == 'dispersal model':
                    self.comboBox_dispModel.setCurrentText(row[1])
                elif row[0] == 'field':
                    for table_row in range(self.tableWidget_vector.rowCount()):
                        if row[2] == self.tableWidget_vector.item(table_row,0).text() and \
                                row[3] == self.tableWidget_vector.item(table_row,1).text():
                            self.tableWidget_vector.selectRow(table_row)
                elif row[0] == 'band':
                    for table_row in range(self.tableWidget_raster.rowCount()):
                        if row[2] == self.tableWidget_raster.item(table_row, 0).text() and \
                                row[3] == self.tableWidget_raster.item(table_row, 1).text():
                            self.tableWidget_raster.selectRow(table_row)
                elif row[0] == 'taxon':
                    rows = self.tableWidget_taxa.rowCount()
                    self.tableWidget_taxa.setRowCount(rows+1)
                    self.tableWidget_taxa.setItem(rows, 0, QTableWidgetItem(row[2]))
                    self.tableWidget_taxa.setItem(rows, 1, QTableWidgetItem(row[3]))
                    self.tableWidget_taxa.setItem(rows, 2, QTableWidgetItem(row[4]))
                    self.tableWidget_taxa.setItem(rows, 3, QTableWidgetItem(row[5]))
                elif row[0] == 'community headers':
                    self.tableWidget_vegCom.setColumnCount(len(row)-2)
                    for item in range(2,len(row)):
                        self.tableWidget_vegCom.setHorizontalHeaderItem(item-2, QTableWidgetItem(row[item]))
                elif row[0] == 'community':
                    self.tableWidget_vegCom.setRowCount(self.tableWidget_vegCom.rowCount()+1)
                    for item in range(2,len(row)):
                        self.tableWidget_vegCom.setItem(self.tableWidget_vegCom.rowCount()-1, item-2, QTableWidgetItem(row[item]))
                elif row[0] == 'sampling site':
                    rows = self.tableWidget_sites.rowCount()
                    self.tableWidget_sites.setRowCount(rows+1)
                    self.tableWidget_sites.setItem(rows, 0, QTableWidgetItem(row[1]))
                    self.tableWidget_sites.setItem(rows, 1, QTableWidgetItem(row[2]))
                    self.tableWidget_sites.setItem(rows, 2, QTableWidgetItem(row[3]))
                    self.tableWidget_sites.setItem(rows, 3, QTableWidgetItem(row[4]))
                elif row[0] == 'file path':
                    selected_sample = row[1]
                    sample_file_path = row[2]
                    if exists(sample_file_path):
                        #load into table
                        rows = self.tableWidget_pollenFile.rowCount()
                        self.tableWidget_pollenFile.setRowCount(rows+1)
                        self.tableWidget_pollenFile.setItem(rows, 0, QTableWidgetItem(row[1]))
                        self.tableWidget_pollenFile.setItem(rows, 1, QTableWidgetItem(row[2]))
                        # load into dict
                        self.dict_pollen_percent_files[selected_sample] = sample_file_path
                        # load into excerpts
                        self.addPollenExcerpt(selected_sample, sample_file_path)
                    else:
                        #path to file not found (likely because it is a different computer)
                        self.addPollenCountsFilePath('Reload')
                        pass
                elif row[0] == 'dispersal model':
                    self.comboBox_dispModel.setCurrentText(row[1])
                elif row[0] == 'atmospheric constant':
                    self.doubleSpin_atmosConstant.setValue(float(row[1]))
                elif row[0] == 'diffusion constant':
                    self.doubleSpin_diffConstant.setValue(float(row[1]))
                elif row[0] == 'windspeed':
                    self.doubleSpin_windSpeed.setValue(float(row[1]))
                elif row[0] == 'Windrose enabled':
                    self.checkBox_enableWindrose.setChecked(bool(row[1]))
                elif row[0] == 'windrose':
                    if self.checkBox_enableWindrose.isChecked:
                        self.doubleSpin_north.setValue(float(row[1]))
                        self.doubleSpin_northEast.setValue(float(row[2]))
                        self.doubleSpin_east.setValue(float(row[3]))
                        self.doubleSpin_southEast.setValue(float(row[4]))
                        self.doubleSpin_south.setValue(float(row[5]))
                        self.doubleSpin_southWest.setValue(float(row[6]))
                        self.doubleSpin_west.setValue(float(row[7]))
                        self.doubleSpin_northWest.setValue(float(row[8]))
                    else:
                        pass # leave default values
                elif row[0] == 'Project name':
                    self.lineEdit_projectName.setText(row[1])
                elif row[0] == 'Author(s)':
                    self.lineEdit_author.setText(row[1])
                elif row[0] == 'changelog':
                    self.listWidget_changeLog.addItem(row[1])
                elif row[0] == 'Description':
                    self.plainTextEdit_description.setPlainText(row[1])
                elif row[0] == 'Notes':
                    self.plainTextEdit_notes.setPlainText(row[1])
                elif row[0] == 'fit':
                    self.comboBox_fit.setCurrentText(row[1])
                    self.doubleSpinBox_fit.setValue(float(row[2]))
                    self.doubleSpinBox_cumulFit.setValue(float(row[3]))
                elif row[0] == 'maps':
                    if row[1] == 'Keep all + loadings':
                        self.radioButton_keepFitted.setChecked(False)
                        self.radioButton_keepTwo.setChecked(False)
                        self.radioButton_keepAll.setChecked(True)
                    elif row[1] == 'Keep all - loadings':
                        self.radioButton_keepFitted.setChecked(False)
                        self.radioButton_keepTwo.setChecked(True)
                        self.radioButton_keepAll.setChecked(False)
                    elif row[1] == 'Keep fit':
                        self.radioButton_keepFitted.setChecked(True)
                        self.radioButton_keepTwo.setChecked(False)
                        self.radioButton_keepAll.setChecked(False)
                else:
                    pass

            rectangle = QgsRectangle(x_min,y_min,x_max,y_max)
            self.mExtentGroupBox.setOutputExtentFromUser(rectangle, crs)

        pass

    def saveFiles(self):
        self.popup_save_file = MsaQgisSaveLoadDialog('save')
        self.popup_save_file.show()
        if self.popup_save_file.exec_():
            file_dialog = QFileDialog()
            file_directory = file_dialog.getExistingDirectory(self, "Choose a directory to load your files from")
            if not file_directory:
                iface.messageBar().pushMessage('Operation cancelled by user', level=1)
                return
            file_name_input = file_directory + '/inputstate.csv'
            file_name_rule_dict = file_directory + '/ruledict.pkl'
            file_name_rule_tree = file_directory + '/ruletree.pkl'
            file_name_hum_file = file_directory + '/backwardsHUMPOL.hum'
            file_name_image_rule_tree = file_directory + '/ruletreeimage.jpg'
            directory_name = file_dialog.directory().dirName()
            if self.popup_save_file.checkBox_input.isChecked():
                self.saveInput(file_name_input, directory_name)
            if self.popup_save_file.checkBox_ruleDict.isChecked():
                self.saveRuleDict(file_name_rule_dict)
            if self.popup_save_file.checkBox_ruleTree.isChecked():
                self.saveRuleTree(file_name_rule_tree)
            if self.popup_save_file.checkBox_humFile.isChecked():
                self.saveHandbagFile(file_name_hum_file)
            if self.popup_save_file.checkBox_loadImageRuleTree.isChecked():
                self.saveImageRuleTree(file_name_image_rule_tree)

    def loadFiles(self):
        self.popup_load_file = MsaQgisSaveLoadDialog('load')
        self.popup_load_file.show()
        if self.popup_load_file.exec_():
            file_dialog = QFileDialog()
            file_directory = file_dialog.getExistingDirectory(self, "Choose a directory to load your files from")
            if not file_directory:
                iface.messageBar().pushMessage('Operation cancelled by user', level=1)
                return
            file_name_input = file_directory + '/inputstate.csv'
            file_name_rule_dict = file_directory + '/ruledict.pkl'
            file_name_rule_tree = file_directory + '/ruletree.pkl'
            if self.popup_load_file.checkBox_input.isChecked():
                self.loadInput(file_name_input)
            if self.popup_load_file.checkBox_ruleDict.isChecked():
                self.loadRuleDict(file_name_rule_dict)
            if self.popup_load_file.checkBox_ruleTree.isChecked():
                self.loadRuleTree(file_name_rule_tree)

        else:
            iface.messageBar().pushMessage('Cancelled operation, no files saved', level=1)

        self.checkChecklist()  # check the checklist for which bits were loaded

### BUTTON FUNCTIONS SPATIAL INPUT TAB
    def setExtent(self):
        """Attaches the extent given by the user to a variable, and updates the 'current extent'
        so that the input can be used in further analysis

        :params from UI files: self.mExtentGroupBox"""
        self.extent = self.mExtentGroupBox.outputExtent()
        self.mExtentGroupBox.setCurrentExtent(self.extent, self.mExtentGroupBox.outputCrs())

    def enableNested(self):
        """Enables or Disables the UI widgets related to nested maps."""
        if self.radioButton_nestedMap.isChecked() and self.radioButton_createMap.isChecked():
            self.spinBox_nestedArea.show()
            self.label_nestedArea.show()
            self.label_resNested.show()
            self.spinBox_resNested.show()
        elif self.radioButton_nestedMap.isChecked() == False:
            self.spinBox_nestedArea.hide()
            self.label_nestedArea.hide()
            self.label_resNested.hide()
            self.spinBox_resNested.hide()

    def checkNestedArea(self):
        """Checks whether the nested area is possible, given the two resolutions. An incorrect area would result
        in either parts of the map that are not sampled, for the purposes of pollen simulated, or are sampled double.
        The spinBox will become red."""
        timer= QBasicTimer
        if self.radioButton_nestedMap.isChecked():
            if self.spinBox_resNested.value() != 0 and self.spinBox_resolution.value() != 0 and self.spinBox_nestedArea.value()!=0:
                if self.spinBox_nestedArea.value() % self.spinBox_resNested.value() != 0 and self.spinBox_nestedArea.value() % self.spinBox_resolution.value() != 0:
                    self.spinBox_nestedArea.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resNested.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resolution.setStyleSheet("background-color: #ffaeaf;")
                elif self.spinBox_nestedArea.value() % self.spinBox_resNested.value() != 0:
                    self.spinBox_nestedArea.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resNested.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resolution.setStyleSheet("")

                elif self.spinBox_nestedArea.value() % self.spinBox_resolution.value() != 0:
                    self.spinBox_nestedArea.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resolution.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resNested.setStyleSheet("")

                else:
                    if self.spinBox_resolution.value() < self.spinBox_resNested.value():
                        self.spinBox_resolution.setStyleSheet("background-color: #ffaeaf;")
                        self.spinBox_resNested.setStyleSheet("background-color: #ffaeaf;")
                        self.spinBox_nestedArea.setStyleSheet("")
                    else:
                        self.spinBox_nestedArea.setStyleSheet("")
                        self.spinBox_resolution.setStyleSheet("")
                        self.spinBox_resNested.setStyleSheet("")
            elif self.spinBox_resNested.value() != 0 and self.spinBox_resolution.value() != 0:
                if self.spinBox_resolution.value() < self.spinBox_resNested.value():
                    self.spinBox_resolution.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_resNested.setStyleSheet("background-color: #ffaeaf;")
                    self.spinBox_nestedArea.setStyleSheet("")
                else:
                    self.spinBox_nestedArea.setStyleSheet("")
                    self.spinBox_resolution.setStyleSheet("")
                    self.spinBox_resNested.setStyleSheet("")


    ### BUTTON FUNCTIONS TAXA & VEGETATION TAB
    def addNewTaxon(self):
        """ Adds a new pollen taxon to the list of taxa by opening a pop-up in which the taxon code, full name,
        fall speed and relative pollen productivity can be given. The popup closes when executed or cancelled.

        :class param: self.taxonPopup
        :params from UI files: self. tableWidget_taxa"""
        self.taxonPopup = MsaQgisAddTaxonPopup()
        self.taxonPopup.show()
        result = self.taxonPopup.exec_()
        # runs when apply is clicked on the add new taxon popup
        if result:
            # Get filled in values
            taxon_short_name = self.taxonPopup.lineEdit_taxonShortName.text()
            taxon_full_name = self.taxonPopup.lineEdit_taxonFullName.text()
            taxon_fall_speed = self.taxonPopup.doubleSpinBox_taxonFallSpeed.value()
            taxon_rpp = self.taxonPopup.doubleSpinBox_taxonRPP.value()
            # Check if entry is valid and add to table
            if taxon_short_name and taxon_full_name and taxon_fall_speed and taxon_rpp:
                row_count = self.tableWidget_taxa.rowCount()
                self.tableWidget_taxa.setRowCount(row_count+1)
                self.tableWidget_taxa.setItem(row_count, 0, QTableWidgetItem(taxon_short_name))
                self.tableWidget_taxa.setItem(row_count, 1, QTableWidgetItem(taxon_full_name))
                self.tableWidget_taxa.setItem(row_count, 2, QTableWidgetItem(str(taxon_fall_speed)))
                self.tableWidget_taxa.setItem(row_count, 3, QTableWidgetItem(str(taxon_rpp)))
            else:
                iface.messageBar().pushMessage('Missing or zero value in add new taxon, '
                                                    'please try again', level=2)
        elif self.taxonPopup.rejected:
            iface.messageBar().pushMessage('Adding taxon cancelled by user', level=0)

    def addNewVegCom(self):
        """ Adds a new vegetation community to the table of communities by opening a pop-up in which a list of species
         and their percentages, as well as a new community name can be given.

         :class params: self.veg_com_popup
         :params from UI files: self.tableWidget_taxa, self.tableWidget_vegCom
         """

        tableWidget_taxa = self.tableWidget_taxa
        tableWidget_vegCom = self.tableWidget_vegCom
        # Pass list of taxa as found in the table of taxa to the popup and open it
        item_list = [tableWidget_taxa.item(row,0).text() for row in range(tableWidget_taxa.rowCount())]
        self.veg_com_popup = MsaQgisAddVegComPopup(item_list)  # Opens popup
        result = self.veg_com_popup.exec_()

        if result:
            # Check for errors, critical, do NOT add entry to table
            veg_com_list = [tableWidget_vegCom.item(row,0).text() for row in range(tableWidget_vegCom.rowCount())]
            if self.veg_com_popup.lineEdit_vegComName.text() == '': # no name was entered, critical error
                iface.messageBar().pushMessage('No name for the vegetation community was entered, '
                                               'please try again.', level=2)
                return
            elif self.veg_com_popup.lineEdit_vegComName.text() in veg_com_list: # vegcom name is already in use
                iface.messageBar().pushMessage('Vegetation community already exists, please try again.', level=2)
                return
            for taxon_name in self.veg_com_popup.taxon_dict: # One of the taxa is set to 0% add without that taxa and give a warning.
                if self.veg_com_popup.taxon_dict[taxon_name].value() == 0:
                    iface.messageBar().pushMessage('One of the taxa did not have percentage assigned, please try again.'
                                                   ,level=2)
                    return
            # Check for errors, warning, DO add entry to table
            if self.veg_com_popup.taxon_dict == {}: # No taxa were added, give warning
                iface.messageBar().pushMessage(f'Vegetation community {self.veg_com_popup.lineEdit_vegComName.text()} '
                                               f'contains no taxa.', level=1)
            # Add entries to table.
            # Create new header if taxon is not yet in tableWidget_vegCom, else add percentage under existing header.
            tableWidget_vegCom.setRowCount(tableWidget_vegCom.rowCount() + 1)
            tableWidget_vegCom.setItem(tableWidget_vegCom.rowCount() - 1, 0, QTableWidgetItem(
                self.veg_com_popup.lineEdit_vegComName.text()))
            header_list = [tableWidget_vegCom.horizontalHeaderItem(column).text()
                           for column in range(1, tableWidget_vegCom.columnCount())]
            for taxon_name in self.veg_com_popup.taxon_dict:  # Check if header already exists
                if taxon_name.currentText() in header_list:  # Header exists, add percentage value to existing column
                    for column in range(tableWidget_vegCom.columnCount()):
                        header_text = tableWidget_vegCom.horizontalHeaderItem(column).text()
                        if header_text == taxon_name.currentText():
                            tableWidget_vegCom.setItem(tableWidget_vegCom.rowCount() - 1, column, 
                                                       QTableWidgetItem(str(self.veg_com_popup.taxon_dict[taxon_name].value())))
                else: #Header does not yet exist, make new.
                    self.tableWidget_vegCom.setColumnCount(self.tableWidget_vegCom.columnCount() + 1)
                    tableWidget_vegCom.setHorizontalHeaderItem(self.tableWidget_vegCom.columnCount() - 1, QTableWidgetItem(
                                taxon_name.currentText()))
                    tableWidget_vegCom.setItem(tableWidget_vegCom.rowCount() - 1, self.tableWidget_vegCom.columnCount() - 1, QTableWidgetItem(
                        str(self.veg_com_popup.taxon_dict[taxon_name].value())))
        elif self.veg_com_popup.rejected:
            iface.messageBar().pushMessage('Adding vegetation community cancelled by user', level=0)

    def removeTaxaEntry(self):
        """ Removes selected entries from a table with a pop-up warning

        :params from UI: self.tableWidget_taxa"""
        # popup
        pass #TODO create pop-up warning
        tableWidget_taxa = self.tableWidget_taxa
        for row in tableWidget_taxa.selectionModel().selectedRows():
            tableWidget_taxa.removeRow(row.row())

    def removeVegComEntry(self):
        """ Removes selected entries from the vegetation community table with a pop-up warning

        :params from UI: self.tableWidget_vegCom"""
        # Popup
         #TODO create pop-up warning


        # Remove the row containing the selected vegcom
        tableWidget_vegCom = self.tableWidget_vegCom
        columns_to_remove = []

        if tableWidget_vegCom.selectionModel().selectedRows():
            for row in tableWidget_vegCom.selectionModel().selectedRows():
                tableWidget_vegCom.removeRow(row.row())
        # Remove columns that no longer contain data after the row was removed
        for column in range(1,tableWidget_vegCom.columnCount()):
            item_list = []
            for row in range(tableWidget_vegCom.rowCount()):
                if tableWidget_vegCom.item(row,column):
                    item_list.append(tableWidget_vegCom.item(row,column))
            if not item_list:
                columns_to_remove.append(column)
        for list_item in columns_to_remove:
            tableWidget_vegCom.removeColumn(list_item)
            tableWidget_vegCom.setColumnCount(self.tableWidget_vegCom.columnCount()-1)
                    
### BUTTON FUNCTIONS RULES TAB
    def addNewRule(self):
        """ Opens a popup that enables adding of new rules under the rules tab in the main dialog UI. The new rule is
        assigned the next available digit, in a range of 0-999.

        :Class params: self.next_dict_rules, self.add_rule_popup

        :params from UI files: self.tableWidget_vegCom, self.tableWidget_selected, self.tableWidget_selRaster,
        self.listWidget_rules"""
        #Determine rule number, takes the next number not yet taken to avoid skipping numbers.
        rule_in_list = False
        if self.nest_dict_rules: # Check if there are any rules in the list
            for counter in range(0,1000): # This means a max of 1000 rules is possible. With current envisioned use, that is generous.
                for entry in self.nest_dict_rules:
                    if counter == self.nest_dict_rules[entry][0]:
                        rule_in_list = True
                        rule_number = len(self.nest_dict_rules)
                        break
                if rule_in_list:
                    rule_in_list = False
                    continue
                elif counter == 999:
                    iface.messageBar().pushMessage('Max number of rules reached', level=1)
                else:
                    rule_number = counter
                    break
        else:
            rule_number = 0

        self.add_rule_popup = MsaQgisAddRulePopup(rule_number, self.tableWidget_vegCom,
                                                  self.tableWidget_selected, self.tableWidget_selRaster)
        self.add_rule_popup.show()
        if self.add_rule_popup.exec_():
            # Add the rule to the dictionary and rule description to the rule listWidget
            self.nest_dict_rules['Rule ' + str(rule_number)] = self.add_rule_popup.list_for_rules_dict
            self.listWidget_rules.addItem(self.nest_dict_rules['Rule ' + str(rule_number)][1])

    def deleteRule(self):
        """ Deletes a selected rule from the rule list widget and dictionary.

        :params from UI files: self.listWidget_rules

        :class params: self.nest_dict_rules"""
        # Check which rule(s) are selected
        list_to_remove = []
        for item in self.listWidget_rules.selectedItems():
            description = item.text()
            self.listWidget_rules.takeItem(self.listWidget_rules.row(item))
            for key in self.nest_dict_rules:
                if self.nest_dict_rules[key][1] == description:
                    list_to_remove.append(key)
        for entry in list_to_remove:
            self.nest_dict_rules.pop(entry)

### BUTTON FUNCTIONS RULE TREE TAB
    def viewRuleList(self):
        """ Opens the list of rules in a separate window for quick reference when creating the rule tree.

        :class params: self.popup_rule_list, self.nest_dict_rules"""
        self.popup_rule_list = MsaQgisRuleListPopup(self.nest_dict_rules)
        self.popup_rule_list.show()

    def checkIfSelectedRule(self):
        """ Checks if there are any selected ruleTreeWidgets in the rule tree.

        :class params: self.nest_dict_rules, self.dict_ruleTreeWidgets

        :returns: The ID of the selected rule, or: -2, no rules found, -1, no rule selected selected, 0 rules in dictionary but not in widgets.
        :rtype: int"""
        selected_rule = -1
        if self.nest_dict_rules: #check if there are any rules in the rule dictionary
            if self.dict_ruleTreeWidgets: # check if there are any RuleTreeWidgets already placed
                for key in self.dict_ruleTreeWidgets: #determine which of the rules in the rule tree is selected
                    if self.dict_ruleTreeWidgets[key].isSelected:
                        selected_rule = key
            else: selected_rule = 0
        else:
            selected_rule = -2
        return selected_rule

    def addRuleToTree(self):
        """ Adds a RuleTreeWidget to the RuleTreeFrame with a 'normal' connection type (not in series, and not a duplicate)
        Based on a selected ruleTreeWidget, unless no ruleTreeWidgets exist, in which case it places the first
        ruleTreeWidget in the emply frame. If the rule is added to a scenario where a series exists, the appropriate
        'duplicate' ruleTreeWidgets are also added. A maximum of 9 rules can be connected to a single rule.

        :class params: self.x, self.y, self.nest_dict_rules, self.dict_ruleTreeWidgets
        :params from UI files: self.scrollArea_ruleTree, self.tabl_top, self.ruleTreeLayout, self.frame_ruleTree
        :class functions: self.checkIfSelectedRule, self.changeRuleTreeSelection"""
        next_layout = QHBoxLayout()
        own_layout = QVBoxLayout()
        x_position_for_spoilerplate = self.scrollArea_ruleTree.x() + self.tab_top.x() + self.x()
        y_position_for_spoilerplate = self.scrollArea_ruleTree.y() + self.tab_top.y() + self.y()
        selected_rule = self.checkIfSelectedRule()
        if selected_rule == -2:  # Check if there are rules in the rule list
            iface.messageBar().pushMessage("Error", "There are no rules to add", level = 1)
            return
        elif selected_rule == -1:  # Check if a ruleTreeWidget was selected
            iface.messageBar().pushMessage("Error", "Select a rule to add a new rule to the rule tree",
                                           level=1)
            return
        elif selected_rule == 0:  # Check if this is the first ruleTreeWidget to be added
            rule_id = 1
            ruleTreeWidget = RuleTreeWidget(self.nest_dict_rules, rule_id, next_layout,
                                            main_dialog_x=x_position_for_spoilerplate,
                                            main_dialog_y=y_position_for_spoilerplate) # duplicate_ruletreewidget for mysterious reasons is not always empty despite never getting anything appended unless specified at creation
            self.ruleTreeLayout.insertWidget(0, ruleTreeWidget) # insert itself
            self.ruleTreeLayout.insertLayout(1, ruleTreeWidget.next_layout) # insert holder for next widgets
            self.ruleTreeLayout.insertStretch(2, 1) # insert stretch to push to top
        else:  # selected_rule contains the ID of a selected ruleTreeWidget
            if self.dict_ruleTreeWidgets[selected_rule].connection_type != 'normal':
                iface.messageBar().pushMessage("Error", "Cannot add a rule to a rule in series. "
                                                        "Use already connected rule instead or replace rule in series with a normal branch",
                                               level=1)
                return
            elif len(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) >= 9:
                iface.messageBar().pushMessage("Error", "Cannot add more than 9 rules to a branch",
                                               level=1)
                return
            else:
                if self.dict_ruleTreeWidgets[
                    selected_rule].next_ruleTreeWidgets:  # NOTE max number of branches possible is 10, but can adjust for higher by adding 00 or 000 in other option. Does need adjustment in making duplicates and other rules as well
                    rule_id = max(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) + 1
                else:
                    rule_id = int(str(self.dict_ruleTreeWidgets[selected_rule].order_id) + '0')
                ruleTreeWidget = RuleTreeWidget(self.nest_dict_rules, rule_id, next_layout, own_layout,
                                                main_dialog_x=x_position_for_spoilerplate,
                                                main_dialog_y=y_position_for_spoilerplate)

                # Determine if selected rule already had a next rule and if yes remove from base group. Then append new rule
                if len(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) == 1 and self.dict_ruleTreeWidgets[selected_rule].isBaseGroup:
                    self.dict_ruleTreeWidgets[selected_rule].toggleBaseGroup()
                    iface.messageBar().pushMessage("Note", "Selected rule removed from base group",
                                                   level=0)
                self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets.append(rule_id)
                # Create own layout and insert itself
                self.dict_ruleTreeWidgets[selected_rule].next_layout.addLayout(own_layout)
                own_layout.addWidget(ruleTreeWidget)
                own_layout.addLayout(next_layout)
                own_layout.insertStretch(2, 1)
                # Determine previous RuleTreeWidgets
                ruleTreeWidget.prev_ruleTreeWidgets = self.dict_ruleTreeWidgets[selected_rule].prev_ruleTreeWidgets.copy()
                ruleTreeWidget.prev_ruleTreeWidgets.append(selected_rule)

                # Check if selected rule has duplicates and if yes create a duplicate
                if self.dict_ruleTreeWidgets[selected_rule].duplicate_ruleTreeWidgets:
                    for duplicate in self.dict_ruleTreeWidgets[selected_rule].duplicate_ruleTreeWidgets:
                        #determine rule id
                        if self.dict_ruleTreeWidgets[duplicate].next_ruleTreeWidgets:
                            rule_id_duplicate = max(self.dict_ruleTreeWidgets[duplicate].next_ruleTreeWidgets) + 1
                        else:
                            rule_id_duplicate = int(str(self.dict_ruleTreeWidgets[duplicate].order_id) + '0')
                        # Create widget
                        ruleTreeWidget_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_duplicate, None, None)
                        # Add to dictionary
                        self.dict_ruleTreeWidgets[rule_id_duplicate] = ruleTreeWidget_duplicate
                        # Determine previous
                        self.dict_ruleTreeWidgets[rule_id_duplicate].prev_ruleTreeWidgets = self.dict_ruleTreeWidgets[duplicate].prev_ruleTreeWidgets.copy()
                        self.dict_ruleTreeWidgets[rule_id_duplicate].prev_ruleTreeWidgets.append(duplicate)
                        # Add to next
                        self.dict_ruleTreeWidgets[duplicate].next_ruleTreeWidgets.append(rule_id_duplicate)
                        # Add to duplicates
                        ruleTreeWidget.duplicate_ruleTreeWidgets.append(rule_id_duplicate)
                        self.dict_ruleTreeWidgets[rule_id_duplicate].duplicate_ruleTreeWidgets.append(rule_id)
        # Add ruleTreeWidget to dict and add prev to list
        self.dict_ruleTreeWidgets[ruleTreeWidget.order_id] = ruleTreeWidget
        # Allow widget to remove selection from other widgets when selected
        ruleTreeWidget.clicked.connect(
            lambda *args, ruleTreeWidget_id=ruleTreeWidget.order_id, ruleTreeWidget=ruleTreeWidget:
            self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
        # Update the frame
        self.frame_ruleTree.update()

### BUTTON FUNCTIONS POLLEN TAB
### BUTTON FUNCTIONS METADATA TAB



    def addRuleToTreeSeries(self):
        """ Adds multiple ruleTreeWidgets to the RuleTreeFrame for the placement of a series branch, or if the selected
        ruleTreeWidget is one in series, adds a ruleTreeWidget to the existing series. Where applicable, 'duplicate'
        type ruleTreeWidgets are also created.
        Cannot be placed as the first RuleTreeWidget.

        """
        # Create the RuleTreeWidgets in series and set as previous 1 and previous 2
        # Create the subsequent (duplicate) RuleTreeWidgets
        # If no previous rule tree widgets give an error.
        # set rule type to 'series'
        next_layout_top = QVBoxLayout()
        own_layout_top = QVBoxLayout()
        next_layout_series = QVBoxLayout()
        own_layout_series = QHBoxLayout()
        own_layout_bottom = None
        next_layout_bottom = QHBoxLayout()

        x_position_for_spoilerplate = self.scrollArea_ruleTree.x() + self.tab_top.x() + self.x()
        y_position_for_spoilerplate = self.scrollArea_ruleTree.y() + self.tab_top.y() + self.y()
        selected_rule = self.checkIfSelectedRule()
        if selected_rule == -2: # Check if rules were made
            iface.messageBar().pushMessage("Error", "There are no rules to add", level = 1)
            return
        elif selected_rule == -1: # Check if a rule was selected
            iface.messageBar().pushMessage("Error", "Select a rule to add a new rule to the rule tree",
                                           level=1)
            return
        elif selected_rule == 0: # Check if this is the first rule
            iface.messageBar().pushMessage("Error", "First rule cannot be in series",
                                           level=1)
            return
        else: # selected_rule contains the ID of the selected ruleTreeWidget
            if len(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) >= 9:  # Check if max branches
                iface.messageBar().pushMessage("Error", "Cannot add more than 9 rules to a branch",
                                               level=1)
                return
            elif self.dict_ruleTreeWidgets[selected_rule].connection_type == 'normal':
                # Create new set of rules in series.
                # Determine rule_ids
                if self.dict_ruleTreeWidgets[
                    selected_rule].next_ruleTreeWidgets:
                    rule_id_top = max(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) + 1
                else:
                    rule_id_top = int(str(self.dict_ruleTreeWidgets[selected_rule].order_id) + '0')
                rule_id_series = int(str(rule_id_top)+'0')
                rule_id_bottom = int(str(rule_id_series)+'0')
                rule_id_series_two = rule_id_bottom+1
                # Create widgets
                ruleTreeWidget_top = RuleTreeWidget(self.nest_dict_rules, rule_id_top, next_layout_top,own_layout_top, 'series start',
                                                main_dialog_x=x_position_for_spoilerplate,
                                                main_dialog_y=y_position_for_spoilerplate)
                ruleTreeWidget_series = RuleTreeWidget(self.nest_dict_rules, rule_id_series, next_layout_series,own_layout_series, 'series',
                                                main_dialog_x=x_position_for_spoilerplate,
                                                main_dialog_y=y_position_for_spoilerplate)
                ruleTreeWidget_series_two = RuleTreeWidget(self.nest_dict_rules, rule_id_series_two, next_layout_series,own_layout_series, 'series',
                                                main_dialog_x=x_position_for_spoilerplate,
                                                main_dialog_y=y_position_for_spoilerplate)
                ruleTreeWidget_bottom = RuleTreeWidget(self.nest_dict_rules, rule_id_bottom, next_layout_bottom,own_layout_bottom, 'normal',
                                                main_dialog_x=x_position_for_spoilerplate,
                                                main_dialog_y=y_position_for_spoilerplate)
                # Place widgets
                self.dict_ruleTreeWidgets[selected_rule].next_layout.addLayout(ruleTreeWidget_top.own_layout)
                ruleTreeWidget_top.own_layout.addWidget(ruleTreeWidget_top)
                ruleTreeWidget_top.own_layout.addLayout(ruleTreeWidget_top.next_layout)
                ruleTreeWidget_top.next_layout.addLayout(ruleTreeWidget_series.own_layout)
                ruleTreeWidget_top.next_layout.addLayout(ruleTreeWidget_series.next_layout)
                ruleTreeWidget_series.own_layout.addWidget(ruleTreeWidget_series)
                ruleTreeWidget_series.own_layout.addWidget(ruleTreeWidget_series_two)
                ruleTreeWidget_series.own_layout.addStretch()
                ruleTreeWidget_series.next_layout.addWidget(ruleTreeWidget_bottom)
                ruleTreeWidget_series.next_layout.addLayout(ruleTreeWidget_bottom.next_layout)

                # Create the duplicate, which is NOT added to the UI
                rule_id_duplicate = int(str(rule_id_series_two) + str(0))
                ruleTreeWidget_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_duplicate, None, None, 'duplicate')

                # Add all relevant id's to relevant dictionaries and lists.
                # Add to rule dictionary
                self.dict_ruleTreeWidgets[ruleTreeWidget_top.order_id] = ruleTreeWidget_top
                self.dict_ruleTreeWidgets[ruleTreeWidget_series.order_id] = ruleTreeWidget_series
                self.dict_ruleTreeWidgets[ruleTreeWidget_bottom.order_id] = ruleTreeWidget_bottom
                self.dict_ruleTreeWidgets[ruleTreeWidget_series_two.order_id] = ruleTreeWidget_series_two
                self.dict_ruleTreeWidgets[ruleTreeWidget_duplicate.order_id] = ruleTreeWidget_duplicate

                # Add to duplicates
                ruleTreeWidget_duplicate.duplicate_ruleTreeWidgets.append(ruleTreeWidget_bottom.order_id)
                ruleTreeWidget_bottom.duplicate_ruleTreeWidgets.append(ruleTreeWidget_duplicate.order_id)

                # Add to next widgets
                self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets.append(ruleTreeWidget_top.order_id)
                ruleTreeWidget_top.next_ruleTreeWidgets.append(ruleTreeWidget_series.order_id)
                ruleTreeWidget_series.next_ruleTreeWidgets.append(ruleTreeWidget_bottom.order_id)
                ruleTreeWidget_series.next_ruleTreeWidgets.append(ruleTreeWidget_series_two.order_id)
                ruleTreeWidget_series_two.next_ruleTreeWidgets.append(ruleTreeWidget_duplicate.order_id)

                # Add to previous widgets
                ruleTreeWidget_top.prev_ruleTreeWidgets = self.dict_ruleTreeWidgets[selected_rule].prev_ruleTreeWidgets.copy()
                ruleTreeWidget_top.prev_ruleTreeWidgets.append(selected_rule)
                ruleTreeWidget_series.prev_ruleTreeWidgets = ruleTreeWidget_top.prev_ruleTreeWidgets.copy()
                ruleTreeWidget_series.prev_ruleTreeWidgets.append(ruleTreeWidget_top.order_id)
                ruleTreeWidget_bottom.prev_ruleTreeWidgets = ruleTreeWidget_series.prev_ruleTreeWidgets.copy()
                ruleTreeWidget_series_two.prev_ruleTreeWidgets = ruleTreeWidget_series.prev_ruleTreeWidgets.copy()
                ruleTreeWidget_bottom.prev_ruleTreeWidgets.append(ruleTreeWidget_series.order_id)
                ruleTreeWidget_series_two.prev_ruleTreeWidgets.append(ruleTreeWidget_series.order_id)
                ruleTreeWidget_duplicate.prev_ruleTreeWidgets = ruleTreeWidget_series_two.prev_ruleTreeWidgets.copy()
                ruleTreeWidget_duplicate.prev_ruleTreeWidgets.append(ruleTreeWidget_series_two.order_id)

                # connect all the widgets to the selection
                ruleTreeWidget_top.clicked.connect(
                    lambda *args, ruleTreeWidget_id = ruleTreeWidget_top.order_id, ruleTreeWidget = ruleTreeWidget_top:
                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
                ruleTreeWidget_series.clicked.connect(
                    lambda *args, ruleTreeWidget_id=ruleTreeWidget_series.order_id, ruleTreeWidget=ruleTreeWidget_series:
                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
                ruleTreeWidget_series_two.clicked.connect(
                    lambda *args, ruleTreeWidget_id=ruleTreeWidget_series_two.order_id, ruleTreeWidget=ruleTreeWidget_series_two:
                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
                ruleTreeWidget_bottom.clicked.connect(
                    lambda *args, ruleTreeWidget_id=ruleTreeWidget_bottom.order_id, ruleTreeWidget=ruleTreeWidget_bottom:
                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))

                # If selected_rule has duplicates, create duplicates for all
                if self.dict_ruleTreeWidgets[selected_rule].duplicate_ruleTreeWidgets:
                    for duplicate in self.dict_ruleTreeWidgets[selected_rule].duplicate_ruleTreeWidgets:
                        # Determine rule id
                        if self.dict_ruleTreeWidgets[
                            duplicate].next_ruleTreeWidgets:  # NOTE max number of branches possible is 10, but can adjust for higher by adding 00 or 000 in other option.
                            rule_id_top_duplicate = max(self.dict_ruleTreeWidgets[duplicate].next_ruleTreeWidgets) + 1
                        else:
                            rule_id_top_duplicate = int(str(self.dict_ruleTreeWidgets[duplicate].order_id) + '0')
                        rule_id_series_duplicate = int(str(rule_id_top_duplicate) + '0')
                        rule_id_bottom_duplicate = int(str(rule_id_series_duplicate) + '0')
                        rule_id_series_two_duplicate = rule_id_bottom_duplicate + 1
                        rule_id_bottom_duplicate_two = int(str(rule_id_series_two_duplicate)+ '0')
                        # Create widget
                        ruleTreeWidget_top_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_top_duplicate, None, None, 'duplicate')
                        ruleTreeWidget_series_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_series_duplicate, None, None, 'duplicate')
                        ruleTreeWidget_series_two_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_series_two_duplicate, None, None, 'duplicate')
                        ruleTreeWidget_bottom_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_bottom_duplicate, None, None, 'duplicate')
                        ruleTreeWidget_bottom_duplicate_two = RuleTreeWidget(self.nest_dict_rules, rule_id_bottom_duplicate_two, None, None, 'duplicate')
                        # Add to dictionary
                        self.dict_ruleTreeWidgets[ruleTreeWidget_top_duplicate.order_id] = ruleTreeWidget_top_duplicate
                        self.dict_ruleTreeWidgets[ruleTreeWidget_series_duplicate.order_id] = ruleTreeWidget_series_duplicate
                        self.dict_ruleTreeWidgets[ruleTreeWidget_series_two_duplicate.order_id] = ruleTreeWidget_series_two_duplicate
                        self.dict_ruleTreeWidgets[ruleTreeWidget_bottom_duplicate.order_id] = ruleTreeWidget_bottom_duplicate
                        self.dict_ruleTreeWidgets[ruleTreeWidget_bottom_duplicate_two.order_id] = ruleTreeWidget_bottom_duplicate_two
                        # Determine previous
                        ruleTreeWidget_top_duplicate.prev_ruleTreeWidgets = \
                            self.dict_ruleTreeWidgets[duplicate].prev_ruleTreeWidgets.copy()
                        ruleTreeWidget_top_duplicate.prev_ruleTreeWidgets.append(duplicate)
                        ruleTreeWidget_series_duplicate.prev_ruleTreeWidgets = \
                            ruleTreeWidget_top_duplicate.prev_ruleTreeWidgets.copy()
                        ruleTreeWidget_series_duplicate.prev_ruleTreeWidgets.append(rule_id_top_duplicate)
                        ruleTreeWidget_series_two_duplicate.prev_ruleTreeWidgets = \
                            ruleTreeWidget_series_duplicate.prev_ruleTreeWidgets.copy()
                        ruleTreeWidget_series_two_duplicate.prev_ruleTreeWidgets.append(rule_id_series_duplicate)
                        ruleTreeWidget_bottom_duplicate.prev_ruleTreeWidgets = \
                            ruleTreeWidget_series.prev_ruleTreeWidgets.copy()
                        ruleTreeWidget_bottom_duplicate.prev_ruleTreeWidgets.append(rule_id_series_duplicate)
                        ruleTreeWidget_bottom_duplicate_two.prev_ruleTreeWidgets = \
                            ruleTreeWidget_series_two.prev_ruleTreeWidgets.copy()
                        ruleTreeWidget_bottom_duplicate_two.prev_ruleTreeWidgets.append(rule_id_series_two_duplicate)
                        # Add to next
                        self.dict_ruleTreeWidgets[duplicate].next_ruleTreeWidgets.append(rule_id_top_duplicate)
                        ruleTreeWidget_top_duplicate.next_ruleTreeWidgets.append(rule_id_series_duplicate)
                        ruleTreeWidget_series_duplicate.next_ruleTreeWidgets.append(rule_id_series_two_duplicate)
                        ruleTreeWidget_series_duplicate.next_ruleTreeWidgets.append(rule_id_bottom_duplicate)
                        ruleTreeWidget_series_two_duplicate.next_ruleTreeWidgets.append(rule_id_bottom_duplicate_two)
                        # Add to duplicates
                        ruleTreeWidget_top.duplicate_ruleTreeWidgets.append(rule_id_top_duplicate)
                        ruleTreeWidget_top_duplicate.duplicate_ruleTreeWidgets.append(rule_id_top)
                        ruleTreeWidget_series.duplicate_ruleTreeWidgets.append(rule_id_series_duplicate)
                        ruleTreeWidget_series_duplicate.duplicate_ruleTreeWidgets.append(rule_id_series)
                        ruleTreeWidget_series_two.duplicate_ruleTreeWidgets.append(rule_id_series_two_duplicate)
                        ruleTreeWidget_series_two_duplicate.duplicate_ruleTreeWidgets.append(rule_id_series_two)
                        ruleTreeWidget_bottom.duplicate_ruleTreeWidgets.append(rule_id_bottom_duplicate)
                        ruleTreeWidget_bottom_duplicate.duplicate_ruleTreeWidgets.append(rule_id_bottom)
                        ruleTreeWidget_duplicate.duplicate_ruleTreeWidgets.append(rule_id_bottom_duplicate)
                        ruleTreeWidget_bottom_duplicate.duplicate_ruleTreeWidgets.append(rule_id_duplicate)
                        ruleTreeWidget_bottom.duplicate_ruleTreeWidgets.append(rule_id_bottom_duplicate_two)
                        ruleTreeWidget_bottom_duplicate_two.duplicate_ruleTreeWidgets.append(rule_id_bottom)
                        ruleTreeWidget_duplicate.duplicate_ruleTreeWidgets.append(rule_id_bottom_duplicate_two)
                        ruleTreeWidget_bottom_duplicate_two.duplicate_ruleTreeWidgets.append(rule_id_duplicate)

            elif self.dict_ruleTreeWidgets[selected_rule].connection_type == 'series start' or self.dict_ruleTreeWidgets[selected_rule].connection_type == 'series':
                # Add a rule in series to an already existing set of rules in series.
                if self.dict_ruleTreeWidgets[selected_rule].connection_type == 'series':
                    # Find series start and set as selected_rule
                    partial_id_to_rm = '0'
                    for number in reversed(str(selected_rule)):
                        if number != '0':
                            partial_id_to_rm += number
                        else:
                            break

                    len_to_keep = len(str(selected_rule))-len(partial_id_to_rm)
                    rule_id_series_top = str(selected_rule)[:len_to_keep]
                    selected_rule = int(rule_id_series_top)

                # Find id of first in and first after series
                first_in_series = str(selected_rule) + '0'
                first_after_series = first_in_series + '0'
                if len(self.dict_ruleTreeWidgets[int(first_after_series)].duplicate_ruleTreeWidgets) > 9:
                    iface.messageBar().pushMessage("Error", "Cannot add more than 9 rules to a branch",
                                                   level=1)
                    return
                own_layout_series = self.dict_ruleTreeWidgets[int(first_in_series)].own_layout
                # Find id of last in series
                list_ids_to_check = []
                contains_only_1 = False
                length_first_in_series = len(first_in_series)
                length_first_after_series = len(first_after_series)
                for key in self.dict_ruleTreeWidgets:
                    if first_in_series == str(self.dict_ruleTreeWidgets[key].order_id)[:length_first_in_series]:

                        for digit in str(self.dict_ruleTreeWidgets[key].order_id)[length_first_in_series:]:
                            if digit != '1':
                                contains_only_1 = False
                                break
                            elif digit == '1':
                                contains_only_1 = True
                    if contains_only_1 == True:
                        list_ids_to_check.append(self.dict_ruleTreeWidgets[key].order_id)
                prev_rule_series = max(list_ids_to_check)
                rule_id = int(str(prev_rule_series) + '1')

                # Create the widget
                ruleTreeWidget = RuleTreeWidget(self.nest_dict_rules, rule_id, next_layout= None,
                                                connection_type='series')
                # Place the widget
                own_layout_series.addWidget(ruleTreeWidget)
                own_layout_series.addStretch()
                # Add to dictionary
                self.dict_ruleTreeWidgets[ruleTreeWidget.order_id] = ruleTreeWidget
                # Add to previous widgets
                self.dict_ruleTreeWidgets[rule_id].prev_ruleTreeWidgets = self.dict_ruleTreeWidgets[prev_rule_series].prev_ruleTreeWidgets.copy()
                ruleTreeWidget.prev_ruleTreeWidgets.append(prev_rule_series)
                # Add to next widgets of previous widgets
                self.dict_ruleTreeWidgets[prev_rule_series].next_ruleTreeWidgets.append(rule_id)
                # Connect visible widgets to selection
                ruleTreeWidget.clicked.connect(
                    lambda *args, ruleTreeWidget_id=ruleTreeWidget.order_id, ruleTreeWidget=ruleTreeWidget:
                    self.changeRuleTreeSelection(ruleTreeWidget_id, ruleTreeWidget))
                # Find all of the next rules after the first series rule and give them duplicates.
                list_ids_to_check = []
                for key in self.dict_ruleTreeWidgets:
                    if first_after_series in str(self.dict_ruleTreeWidgets[key].order_id)[:length_first_after_series]:
                        if len(str(self.dict_ruleTreeWidgets[key].order_id)) > length_first_in_series:
                            list_ids_to_check.append(self.dict_ruleTreeWidgets[key].order_id)
                for id in list_ids_to_check:
                    rule_id_duplicate = int(str(rule_id) + str(id)[length_first_in_series:])
                    ruleTreeWidget_duplicate = RuleTreeWidget(self.nest_dict_rules, rule_id_duplicate, None, None,
                                                              'duplicate')
                    # Add to dictionary
                    self.dict_ruleTreeWidgets[ruleTreeWidget_duplicate.order_id] = ruleTreeWidget_duplicate
                    # Add to previous widgets
                    prev_rule_id = int(str(rule_id_duplicate)[:len(str(rule_id_duplicate))-1])
                    self.dict_ruleTreeWidgets[rule_id_duplicate].prev_ruleTreeWidgets = self.dict_ruleTreeWidgets[
                        prev_rule_id].prev_ruleTreeWidgets.copy()
                    self.dict_ruleTreeWidgets[rule_id_duplicate].prev_ruleTreeWidgets.append(prev_rule_id)

                    # Add to next widgets
                    self.dict_ruleTreeWidgets[prev_rule_id].next_ruleTreeWidgets.append(rule_id_duplicate)
                    # Add to duplicates
                    for duplicate in self.dict_ruleTreeWidgets[id].duplicate_ruleTreeWidgets:
                        self.dict_ruleTreeWidgets[duplicate].duplicate_ruleTreeWidgets.append(rule_id_duplicate)
                        self.dict_ruleTreeWidgets[rule_id_duplicate].duplicate_ruleTreeWidgets.append(self.dict_ruleTreeWidgets[duplicate].order_id)
                    self.dict_ruleTreeWidgets[rule_id_duplicate].duplicate_ruleTreeWidgets.append(id)
                    self.dict_ruleTreeWidgets[id].duplicate_ruleTreeWidgets.append(rule_id_duplicate)

        # # Test whether created rules and relations are okay
        # for entries in self.dict_ruleTreeWidgets:
        #     if self.dict_ruleTreeWidgets[entries].duplicate_ruleTreeWidgets:
        #         for next in self.dict_ruleTreeWidgets[entries].duplicate_ruleTreeWidgets:
        #             print(str(entries), ' duplicate', str(next))
        #     for next in self.dict_ruleTreeWidgets[entries].next_ruleTreeWidgets:
        #         print(str(entries), ' next rtw ', str(next))

        self.frame_ruleTree.update()

    def changeRuleTreeSelection(self, ruleTreeWidget_id, ruleTreeWidget):
        """ (De-)Select a ruleTreeWidget. If a new ruleTreeWidget is selected, all previously selected ruleTreeWidgets
        are deselected. Selection is indicated by colouring the ruleTreeWidget red and setting the border to inset
        instead of outset."""
        dict_for_remove_selection = self.dict_ruleTreeWidgets.copy()
        dict_for_remove_selection.pop(ruleTreeWidget_id)

        if ruleTreeWidget.isSelected == True:
            ruleTreeWidget.isSelected = False
            if ruleTreeWidget.isBaseGroup == True:
                ruleTreeWidget.setStyleSheet("background-color: #c37676;"
                                   "border: 3px outset #5b3737;")
            else:
                ruleTreeWidget.setStyleSheet("background-color: #c3c3c3;"
                                   "border: 3px outset #5b5b5b;")
        elif ruleTreeWidget.isSelected == False:
            for key in dict_for_remove_selection:
                if dict_for_remove_selection[key].isSelected == True:
                    dict_for_remove_selection[key].isSelected = False
                    if dict_for_remove_selection[key].isBaseGroup == True:
                        dict_for_remove_selection[key].setStyleSheet("background-color: #c37676;"
                                                                     "border: 3px outset #5b3737;")
                    else:
                        dict_for_remove_selection[key].setStyleSheet("background-color: #c3c3c3;"
                                                                     "border: 3px outset #5b5b5b;")
            ruleTreeWidget.isSelected = True
            ruleTreeWidget.setStyleSheet("background-color: #7dc376;"
                                         "border: 3px inset #3a5b37;")

    def addAndRemoveFromBaseGroup(self):
        """Adds or removes a ruleTreeWidget from the basegroup"""
        for ruleTreeWidget in self.dict_ruleTreeWidgets:
                if self.dict_ruleTreeWidgets[ruleTreeWidget].isSelected == True:
                    if len(self.dict_ruleTreeWidgets[ruleTreeWidget].prev_ruleTreeWidgets) >0:
                        for previous in self.dict_ruleTreeWidgets[ruleTreeWidget].prev_ruleTreeWidgets:
                            if len(self.dict_ruleTreeWidgets[previous].next_ruleTreeWidgets) <= 1:
                                pass
                            else:
                                iface.messageBar().pushMessage("Error", "branched rules cannot be base group",
                                                               level=1)  # TODO replace with popup
                                return #exit function
                        self.dict_ruleTreeWidgets[ruleTreeWidget].toggleBaseGroup()
                    else:
                        self.dict_ruleTreeWidgets[ruleTreeWidget].toggleBaseGroup()

    def removeRuleFromRuleTree(self):
        """ Removes a ruleTreeWidget and its next_ruleTreeWidgets from the rule tree, and the IDs of those
        ruleTreeWidgets from any lists and dicts in which they occur"""
        list_to_delete = []
        selected_rule = self.checkIfSelectedRule()
        if selected_rule < 1:
            return
        else:
            if self.dict_ruleTreeWidgets[selected_rule].connection_type == 'series':
                iface.messageBar().pushMessage("Error", "Cannot remove rule from middle of series, "
                                                        "select rule above series instead", level=1)

            elif selected_rule == 1: # first rule needs seperate process because otherwise the max() statement in the next elif will fail. Ugly but I'm tired and ctrl-v is my friend. WIll remove when implemeting proper removal of series
                self.clearLayout(self.ruleTreeLayout)
                self.dict_ruleTreeWidgets = {}

            elif self.dict_ruleTreeWidgets[max(self.dict_ruleTreeWidgets[selected_rule].prev_ruleTreeWidgets)].connection_type == 'series':
                iface.messageBar().pushMessage("Error", "Cannot remove rule from middle of series, "
                                                        "select rule above series instead", level=1)

            else:
                for key in self.dict_ruleTreeWidgets:
                    #check if selected rule is a previous rule, if yes delete that rule and its layouts
                    if selected_rule in self.dict_ruleTreeWidgets[key].prev_ruleTreeWidgets:
                        if self.dict_ruleTreeWidgets[key].own_layout:
                            self.dict_ruleTreeWidgets[key].own_layout.deleteLater()
                        if self.dict_ruleTreeWidgets[key].next_layout:
                            self.dict_ruleTreeWidgets[key].next_layout.deleteLater()
                        self.dict_ruleTreeWidgets[key].deleteLater()
                        list_to_delete.append(key)
                    #check if rule is duplicate of selected rule, if yes delete that rule
                    elif selected_rule in self.dict_ruleTreeWidgets[key].duplicate_ruleTreeWidgets:
                        if self.dict_ruleTreeWidgets[key].own_layout:
                            self.dict_ruleTreeWidgets[key].own_layout.deleteLater()
                        if self.dict_ruleTreeWidgets[key].next_layout:
                            self.dict_ruleTreeWidgets[key].next_layout.deleteLater()
                        self.dict_ruleTreeWidgets[key].deleteLater()
                        list_to_delete.append(key)
                #then delete the selected rule and its layouts itself
                if self.dict_ruleTreeWidgets[selected_rule].own_layout:
                    self.dict_ruleTreeWidgets[selected_rule].own_layout.deleteLater()
                if self.dict_ruleTreeWidgets[selected_rule].next_layout:
                    self.dict_ruleTreeWidgets[selected_rule].next_layout.deleteLater()
                self.dict_ruleTreeWidgets[selected_rule].deleteLater()
                list_to_delete.append(selected_rule)

            #remove entries from dictionary
            for entry in list_to_delete:
                self.dict_ruleTreeWidgets.pop(entry)
            #remove selected rule from next_ruletreewidgets of its previous rule
            for key in self.dict_ruleTreeWidgets:
                for item in list_to_delete:
                    if item in self.dict_ruleTreeWidgets[key].next_ruleTreeWidgets:
                        self.dict_ruleTreeWidgets[key].next_ruleTreeWidgets.remove(item)
            #update the UI
            self.frame_ruleTree.update()

    def clearLayout(self, layout):
        """ Recurively clears a layout of all its widgets and layouts."""
        while layout.count():
            child = layout.takeAt(0)
            if child.widget() is not None:
                child.widget().deleteLater()
            elif child.layout() is not None:
                self.clearLayout(child.layout())
                child.layout().setParent(None)

    def addSamplingSite(self):
        """ Opens a popup in which the user can give the location, name and type of a sampling site"""
        add_sampling_site_popup = MsaQgisAddSite()
        add_sampling_site_popup.show()
        if add_sampling_site_popup.exec_():
            row_count = self.tableWidget_sites.rowCount()
            self.tableWidget_sites.setRowCount(row_count+1)

            self.tableWidget_sites.setItem(row_count, 0, QTableWidgetItem(add_sampling_site_popup.lineEdit_siteName.text()))
            self.tableWidget_sites.setItem(row_count, 1, QTableWidgetItem(str(add_sampling_site_popup.doubleSpin_x.value())))
            self.tableWidget_sites.setItem(row_count, 2, QTableWidgetItem(str(add_sampling_site_popup.doubleSpin_y.value())))
            if add_sampling_site_popup.radioButton_lake.isChecked():
                self.tableWidget_sites.setItem(row_count, 3, QTableWidgetItem("yes"))
            else:
                self.tableWidget_sites.setItem(row_count, 3, QTableWidgetItem("no"))

    def removeSamplingSite(self):
        """ Removes a sampling site from the table of sites"""
        #TODO cannot remove sampling site if it has associated pollen counts OR also remove associated pollen counts
        if self.tableWidget_sites.selectionModel().selectedRows():
            for row in self.tableWidget_sites.selectionModel().selectedRows():
                selected_sample = self.tableWidget_sites.itemAt(row.row(), 0).text()

                #get name of selected row
                #check if sample site name is also in pollen file paths table. If yes, also delete.
                #set selection to associated row in pollen file table, then run removal
                for row_file in range(self.tableWidget_pollenFile.rowCount()):
                    if self.tableWidget_pollenFile.itemAt(row_file, 0).text() == selected_sample:
                        self.tableWidget_pollenFile.setCurrentCell(row_file, 0)
                        self.removePollenCountsFilePath()
                self.tableWidget_sites.removeRow(row.row())

    def addPollenCountsFilePath(self, isReload = False):
        """ Opens a popup in which the user can a link to a .csv file containing pollen counts. The path is added to a list and can be consulted by
        other parts of the UI from a dictionary. A pollen dataset can only be added to a sampling site that already exists in the sampling
        site table, and no duplicates are allowed"""

        if self.tableWidget_sites.rowCount() == 0:
            iface.messageBar().pushMessage('There are no sampling points to connect to.', level=1)
            return
        self.add_pollen_percentage_popup = MsaQgisAddPercentPopup(self.tableWidget_sites)
        if isReload: # THIS IS TEMPORARY TODO
            self.add_pollen_percentage_popup.label_title.setText('File path in save file was not valid, choose a new path to the file')
        self.add_pollen_percentage_popup.show()
        if self.add_pollen_percentage_popup.exec_():
            selected_sample = self.add_pollen_percentage_popup.comboBox_samplingPoint.currentText()
            sample_file_path = self.add_pollen_percentage_popup.mQgsFileWidget_PollenPercent.filePath()
            #make sure entry is not a duplicate
            for entry in range(self.tableWidget_pollenFile.rowCount()):
                if self.tableWidget_pollenFile.itemAt(entry, 0).text() == selected_sample:
                    iface.messageBar().pushMessage('Sampling site already has an associated file.', level=1)
                    return
            #add file path to UI, dictionary and show excerpt of pollen in the pollen table/tabs
            if sample_file_path:
                row_count = self.tableWidget_pollenFile.rowCount()
                self.tableWidget_pollenFile.setRowCount(row_count + 1)
                self.dict_pollen_percent_files[selected_sample] = sample_file_path
                self.tableWidget_pollenFile.setItem(row_count, 0, QTableWidgetItem(selected_sample))
                self.tableWidget_pollenFile.setItem(row_count, 1, QTableWidgetItem(sample_file_path))
                self.addPollenExcerpt(selected_sample, sample_file_path)

            else:
                iface.messageBar().pushMessage('No file was chosen.', level=1)
                return

                #create signals to delete later- not sure yet if necessary as tabs should be deletable by name

    def addPollenExcerpt(self, selected_sample, sample_file_path):
        """ Creates a new tab in tabWidget_countSheets and new table therein that shows an excepts of the contents of
        the pollen file, or indicates that the file or file path is incorrect"""
        # create QtableWidget
        tableWidget_percentages = QTableWidget()
        self.tabWidget_countSheets.addTab(tableWidget_percentages, selected_sample)
        # remove the dummy tab, if it is not already removed
        dummy_page = self.tabWidget_countSheets.findChild(QWidget, 'tab_dummySample')
        if dummy_page:
            index = self.tabWidget_countSheets.indexOf(dummy_page)
            self.tabWidget_countSheets.removeTab(index)
        # fill tablewidget percentages with file entry
        ##TODO create option for no file found (for if the file moved and the path changed)
        if sample_file_path[-4:] == '.csv':
            table_row_count = tableWidget_percentages.rowCount()
            tableWidget_percentages.setColumnCount(3)
            tableWidget_percentages.setHorizontalHeaderItem(0, QTableWidgetItem('Code'))
            tableWidget_percentages.setHorizontalHeaderItem(1, QTableWidgetItem('Full Name'))
            tableWidget_percentages.setHorizontalHeaderItem(2, QTableWidgetItem(selected_sample + '%'))

            with open(sample_file_path, mode='r') as file:
                pollen_counts_csv = csv.reader(file)
                next(pollen_counts_csv)  # skip first line
                for index, line in enumerate(pollen_counts_csv):
                    if index >= 10:  # only compute the first 10 lines
                        break
                    if line[0] == 'Code' and line[1] == 'Name':  # find the line with sample names
                        for column in line:
                            if column == selected_sample:
                                sample_column = line.index(column)
                    else:
                        table_row_count = table_row_count + 1
                        tableWidget_percentages.setRowCount(table_row_count)
                        tableWidget_percentages.setItem(table_row_count - 1, 0, QTableWidgetItem(line[0]))
                        tableWidget_percentages.setItem(table_row_count - 1, 1, QTableWidgetItem(line[1]))
                        tableWidget_percentages.setItem(table_row_count - 1, 2,
                                                        QTableWidgetItem(line[sample_column]))

                pass
        elif sample_file_path[:4] == '.til' \
                or sample_file_path[:4] == '.txl':
            # TODO read the tilia files
            pass
        else:
            tableWidget_percentages.setRowCount(1)
            tableWidget_percentages.setColumnCount(1)
            tableWidget_percentages.horizontalHeader().setStretchLastSection(True)
            tableWidget_percentages.setItem(0, 0, QTableWidgetItem('Cannot read file type'))

    def removePollenCountsFilePath(self):
        """ Removes the file path of a sample site from table, as well as the entry into the table with pollen counts"""
        if self.tableWidget_pollenFile.selectionModel().selectedRows():
            for row in self.tableWidget_pollenFile.selectionModel().selectedRows():
                #get index row
                row_index = row.row()
                selected_sample = self.tableWidget_pollenFile.item(row_index, 0).text()
                #find related and delete tab
                for index in range(self.tabWidget_countSheets.count()):
                    if self.tabWidget_countSheets.tabText(index) == selected_sample:
                        selected_tab_index = index
                self.tabWidget_countSheets.removeTab(selected_tab_index)
                #find related and delete dictionary entry
                self.dict_pollen_percent_files.pop(selected_sample)
                #find and delete table entry
                self.tableWidget_pollenFile.removeRow(row_index)

    def addToChangeLog(self):
        """ Adds the entry in the lineEdit for the changelog to the listWidget for the changeLog"""
        time_changelog = time.strftime("[%Y-%m-%d] [%H:%M]", time.localtime())
        changelog_entry = self.lineEdit_changeLog.text()
        self.listWidget_changeLog.addItem(f'{time_changelog} -  {changelog_entry}')
        self.lineEdit_changeLog.setText('')

    def removeFromChangeLog(self):
        """ Removes the last entry from the changelog listwidget."""
        #Allowing only the removal of the last item is intentional, as it shouldn't be too easy to remove older entries
        #to the changelog, however one should be able to fix typoes...
        self.listWidget_changeLog.takeItem(self.listWidget_changeLog.count()-1)

    def runAbortedPopup(self, message, e): # TODO implement!
        """ Opens a popup that shows why the run was aborted

        :param message: message that explains why the run was aborted
        :type message: str

        :param e: exception raised in the code
        :type e: Exception"""
        print(f'open messagebox error \n{message}\n {e}')
        self.messageBox = QMessageBox()
        self.messageBox.setWindowTitle('Critical Error, run aborted.')
        self.messageBox.setText(f'{message}\n {e} \n Check MSA_QGIS.log in your output folder for more information')
        self.messageBox.setStandardButtons(QMessageBox.Ok)


class MsaQgisAddRulePopup (QtWidgets.QDialog, FORM_CLASS_RULES):
    def __init__(self, rule_number, tableWidget_vegCom, tableWidget_selected, tableWidget_selRaster, parent = None):
        """Popup Constructor"""
        super(MsaQgisAddRulePopup, self).__init__(parent)
        self.setupUi(self)

        # Class variables
        self.rule_number = rule_number
        self.tableWidget_vegCom = tableWidget_vegCom
        self.tableWidget_selected = tableWidget_selected
        self.tableWidget_selRaster = tableWidget_selRaster
        self.n_of_vegcom = 1
        self.n_of_envvar = 1

        # Dictionaries & lists
        self.list_prevVegCom = []
        self.dict_envVar = {}
        self.list_for_rules_dict = []

        # Set (in)visible
        self.label_rangeMinMax.hide()
        self.doubleSpin_rangeMin.hide()
        self.doubleSpin_rangeMax.hide()
        self.label_category.hide()
        self.comboBox_category.hide()
        self.label_nDistance.hide()
        self.spinBox_nOfDistance.hide()
        self.label_condTypePrevVeg.hide()
        self.label_condTypeEnvVar.hide()

        # Events
        self.rejected.connect(self.closeAll)
        self.pushButton_condVegCom.clicked.connect(self.addConditionalPrevVegCom)
        self.pushButton_condEnvVar.clicked.connect(self.addConditionalEnvVar)
        self.comboBox_envVar.currentTextChanged.connect(lambda: self.addRangeOrCatToEnvVar(self.comboBox_envVar,
                                                                                   self.label_rangeMinMax,
                                                                                   self.doubleSpin_rangeMin,
                                                                                   self.doubleSpin_rangeMax,
                                                                                   self.label_selectEnvVar,
                                                                                   self.label_category,
                                                                                   self.comboBox_category))
        self.comboBox_rule.currentTextChanged.connect(self.addNofPointsToRule)
        self.accepted.connect(self.updateDictionary)
        self.pushButton_checkRule.clicked.connect(lambda: self.updateRuleDescription(self.label_writtenRule))
        #TODO give warnings for empty boxes
        self.buttonBox.accepted.connect(self.checkIfLegit)

        # Fill comboBoxes
        for row in range(self.tableWidget_vegCom.rowCount()):
            self.comboBox_ruleVegCom.addItem(self.tableWidget_vegCom.item(row, 0).text())
            self.comboBox_prevVegCom.addItem(self.tableWidget_vegCom.item(row, 0).text())
        for row in range(self.tableWidget_selected.rowCount()):
            self.comboBox_envVar.addItem(self.tableWidget_selected.item(row, 0).text()+' - '+self.tableWidget_selected.item(row,1).text())
        for row in range(self.tableWidget_selRaster.rowCount()):
            self.comboBox_envVar.addItem(self.tableWidget_selRaster.item(row, 0).text()+' - '+self.tableWidget_selRaster.item(row,1).text())
        #set min & max size for comboBox envVar
        self.label_writtenRule.setText('Rule '+str(rule_number))

    def closeAll(self):
        """ Closes all associated popups when rule dialog is closed"""
        try: self.messageBox.close()
        except: pass

    def addRangeOrCatToEnvVar(self, env_var, label_range, rangeMin, rangeMax,label_noChoice, label_category, category):
        """ An option to fill in range for the environmental variable appears if the variable is numerical"""
        #get layer associated with current item
        category.clear()
        rangeMin.clear()
        rangeMax.clear()
        if env_var.currentText() == 'Empty':
            label_range.hide()
            rangeMin.hide()
            rangeMax.hide()
            label_noChoice.show()
            label_category.hide()
            category.hide()
        else:
            layer_name = list(re.split(' - ', env_var.currentText()))[0]
            field_or_band = list(re.split(' - |:', env_var.currentText()))[1]
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            data_provider = layer.dataProvider()
            if (layer.type() == layer.VectorLayer):
                field_index = data_provider.fieldNameIndex(field_or_band)
                field = data_provider.fields().at(field_index)
                if field.type() == 10 or field.type() == 1: # 10 is str, 1 is bool TODO check if these and int & double are the only options
                    label_range.hide()
                    rangeMin.hide()
                    rangeMax.hide()
                    label_noChoice.hide()
                    label_category.show()
                    category.show()
                    #get categories from fields
                    list_items_combobox = []
                    for feat in data_provider.getFeatures():
                        feat_field = feat.attribute(field.name())
                        if str(feat_field) in list_items_combobox:
                            pass
                        else:
                            list_items_combobox.append(str(feat_field))
                            category.addItem(str(feat_field))

                else:
                    label_range.show()
                    rangeMin.show()
                    rangeMax.show()
                    label_noChoice.hide()
                    label_category.hide()
                    category.hide()
                    #get range from fields
                    rangeMin.setMinimum(data_provider.minimumValue(field_index))
                    rangeMin.setMaximum(data_provider.maximumValue(field_index))
                    rangeMax.setMinimum(data_provider.minimumValue(field_index))
                    rangeMax.setMaximum(data_provider.maximumValue(field_index))
                pass
            elif layer.type() == layer.RasterLayer:
                band_nr = int(list(re.split(' ',field_or_band))[1]) #TODO check if the format 'band [number]:' is consistent for all raster layers!
                if data_provider.dataType(band_nr) != 0: # Checks if band contains numerical data
                    label_range.show()
                    rangeMin.show()
                    rangeMax.show()
                    label_noChoice.hide()
                    label_category.hide()
                    category.hide()
                    #get range from bands
                    stats = data_provider.bandStatistics(band_nr, QgsRasterBandStats.All)
                    minimum_value = stats.minimumValue
                    maximum_value = stats.maximumValue
                    rangeMin.setMinimum(minimum_value)
                    rangeMin.setMaximum(maximum_value)
                    rangeMax.setMinimum(minimum_value)
                    rangeMax.setMaximum(maximum_value)
                else: #NOTE honestly, currently not necessary, unless there is a way to find out if a raster layer is actually categorical...
                    label_range.hide()
                    rangeMin.hide()
                    rangeMax.hide()
                    label_noChoice.hide()
                    label_category.show()
                    category.show()
                    #get categories from band TODO don't think there is currently a way to do this
        pass

    def addNofPointsToRule(self):
        """ Makes a spin box appear when adjacent or encroach is selected under choose rule type"""
        if self.comboBox_rule.currentText() == 'Encroach' or self.comboBox_rule.currentText() == 'Adjacent':
            self.label_nDistance.show()
            self.spinBox_nOfDistance.show()
        else:
            self.label_nDistance.hide()
            self.spinBox_nOfDistance.hide()
        pass

    def addConditionalPrevVegCom(self):
        """ A comboBox appears from which the user can choose whether they want to apply OR or AND rules, and an
        extra row where an additional previous vegetation community can be chosen appears """
        self.label_condTypePrevVeg.show()
        self.radioButton_any.hide()
        self.radioButton_any.setChecked(False)
        # create new widgets
        comboBox_prevVegCom = QComboBox()
        label_prevVegCom = QLabel()
        pushButton_rmPrevVegCom = QPushButton('Remove conditional')

        #fill combobox
        comboBox_prevVegCom.addItem('Empty')
        for row in range(self.tableWidget_vegCom.rowCount()):
            comboBox_prevVegCom.addItem(self.tableWidget_vegCom.item(row, 0).text())
        #create layouts
        vLayout_prevVegCom = QVBoxLayout()
        vLayout_removeButton = QVBoxLayout()
        hLayout_prevVegCom = QHBoxLayout()
        widget_total = QWidget()
        #fill layouts
        vLayout_prevVegCom.addWidget(label_prevVegCom)
        vLayout_prevVegCom.addWidget(comboBox_prevVegCom)
        vLayout_removeButton.addWidget(pushButton_rmPrevVegCom)
        vLayout_removeButton.insertStretch(0)
        hLayout_prevVegCom.addLayout(vLayout_prevVegCom)
        hLayout_prevVegCom.addLayout(vLayout_removeButton)
        widget_total.setLayout(hLayout_prevVegCom)

        self.vLayout_total.insertWidget(self.n_of_vegcom + 1, widget_total)
        #event for subsequent remove
        pushButton_rmPrevVegCom.clicked.connect(lambda *args, widget = widget_total:
                                                self.removeConditionalPrevVegCom(widget_total))

        self.n_of_vegcom +=1
        self.list_prevVegCom.append(comboBox_prevVegCom)

        pass

    def removeConditionalPrevVegCom(self, widget_to_remove):
        """ Removes selected conditionals that were added to the UI. If all but the start prev veg com are gone, the all
         radioButton reappears and choose condition type comboBox disappears"""
        widget_to_remove.deleteLater()
        self.n_of_vegcom -=1

        # TODO make it delete from list

        if self.n_of_vegcom == 1:
            self.label_condTypePrevVeg.hide()
            self.radioButton_any.show()

    def addConditionalEnvVar(self):
        """ A comboBox appears from which the user can choose whether the want to apply OR or AND rules, and an
        extra row where an additional environmental variable can be chosen appears"""
        self.label_condTypeEnvVar.show()

        # create new widgets
        label_envVar = QLabel()
        comboBox_envVar = QComboBox()
        label_range = QLabel('Range')
        doubleSpin_rangeMin = QDoubleSpinBox()
        doubleSpin_rangeMax = QDoubleSpinBox()
        label_noChoice = QLabel('[No environmental variable selected]')
        label_chooseCategory = QLabel('Category')
        comboBox_category = QComboBox()
        pushButton_rmPrevVegCom = QPushButton('Remove conditional')

        # fill combobox
        comboBox_envVar.addItem('Empty')
        for row in range(self.tableWidget_selected.rowCount()):
            comboBox_envVar.addItem(self.tableWidget_selected.item(row, 0).text()+' - '+self.tableWidget_selected.item(row,1).text())
        for row in range(self.tableWidget_selRaster.rowCount()):
            comboBox_envVar.addItem(self.tableWidget_selRaster.item(row, 0).text()+' - '+self.tableWidget_selRaster.item(row,1).text())

        # create layouts
        vLayout_envVar = QVBoxLayout()
        vLayout_rangeOrCat = QVBoxLayout()
        hLayout_range = QHBoxLayout()
        vLayout_removeButton = QVBoxLayout()
        hLayout_envVar = QHBoxLayout()
        widget_total = QWidget()

        # fill layouts
        vLayout_envVar.addWidget(label_envVar)
        vLayout_envVar.addWidget(comboBox_envVar)
        vLayout_rangeOrCat.addWidget(label_range)
        hLayout_range.addWidget(doubleSpin_rangeMin)
        hLayout_range.addWidget(doubleSpin_rangeMax)
        vLayout_rangeOrCat.addLayout(hLayout_range)
        vLayout_rangeOrCat.addWidget(label_noChoice)
        vLayout_rangeOrCat.addWidget(label_chooseCategory)
        vLayout_rangeOrCat.addWidget(comboBox_category)
        vLayout_removeButton.addWidget(pushButton_rmPrevVegCom)
        vLayout_removeButton.insertStretch(0)
        hLayout_envVar.addLayout(vLayout_envVar)
        hLayout_envVar.addLayout(vLayout_rangeOrCat)
        hLayout_envVar.addLayout(vLayout_removeButton)
        widget_total.setLayout(hLayout_envVar)
        self.vLayout_total.insertWidget(self.n_of_envvar+2 + self.n_of_vegcom, widget_total)

        # hide
        label_range.hide()
        doubleSpin_rangeMin.hide()
        doubleSpin_rangeMax.hide()
        label_chooseCategory.hide()
        comboBox_category.hide()

        # create signals (to hide/show range/category and to remove later
        comboBox_envVar.currentTextChanged.connect(lambda *args, env_var = comboBox_envVar, label_range = label_range, rangeMin =doubleSpin_rangeMin,
                                                          rangeMax = doubleSpin_rangeMax, label_noChoice = label_noChoice,
                                                          label_category = label_chooseCategory,category = comboBox_category:
                                                   self.addRangeOrCatToEnvVar(env_var, label_range, rangeMin, rangeMax,
                                                                              label_noChoice, label_category, category))
        pushButton_rmPrevVegCom.clicked.connect(lambda *args, widget = widget_total:
                                                self.removeConditionalEnvVar(widget))
        #pass stuff on along to list


        self.n_of_envvar += 1
        self.dict_envVar[comboBox_envVar] = [doubleSpin_rangeMin, doubleSpin_rangeMax, comboBox_category] # cat_range_none(str), rangeMin, rangeMax, category
        pass

    def removeConditionalEnvVar(self, widget):
        """ Removes selected conditionals that were added to the UI. If all but the start env var are gone,
        the choose conditional type comboBox disappears"""
        for child in widget.children():
            if isinstance(child, QComboBox):
                self.dict_envVar.pop(child)
                break

        widget.deleteLater()
        self.n_of_envvar -= 1

        if self.n_of_envvar == 1:
            self.label_condTypeEnvVar.hide()
            pass

    def updateDictionary(self):
        """ Fills in all of the parameters the user has given in the UI in a list to be added to the dictionary in the
        main dialog"""
        self.list_for_rules_dict.clear()
        #lists and dicts
        list_prevVegCom = []
        dict_envVar = {}
        # insert from static objects
        self.list_for_rules_dict.append(self.rule_number)
        self.list_for_rules_dict.append(self.updateRuleDescription())
        self.list_for_rules_dict.append(self.comboBox_ruleVegCom.currentText())
        self.list_for_rules_dict.append(self.comboBox_rule.currentText())
        self.list_for_rules_dict.append(self.doubleSpin_chance.value())
        self.list_for_rules_dict.append(self.spinBox_nOfDistance.value())
        self.list_for_rules_dict.append(self.n_of_vegcom)
        self.list_for_rules_dict.append(self.n_of_envvar)
        self.list_for_rules_dict.append(self.radioButton_any.isChecked())

        # insert from dynamically added widgets
        # previous vegetation communities
        list_prevVegCom.append(self.comboBox_prevVegCom.currentText())
        for vegcoms in self.list_prevVegCom:
            list_prevVegCom.append(vegcoms.currentText())
        self.list_for_rules_dict.append(list_prevVegCom)
        # environmental variables
        # add the static env var to the dict
        if self.comboBox_category.currentText() == '':
            dict_envVar[self.comboBox_envVar.currentText()] = [self.doubleSpin_rangeMin.value(), self.doubleSpin_rangeMax.value()]
        else:
            dict_envVar[self.comboBox_envVar.currentText()] = self.comboBox_category.currentText()
        #add the non-static env var to the dict
        #generate dictionary based on input, add the value or category to the key to make a unique key in case the key is already in use
        for key in self.dict_envVar:
            if self.dict_envVar[key][2].currentText() == '':
                if key.currentText() in dict_envVar:
                    dict_envVar[key.currentText() + ' - ' + str(self.dict_envVar[key][0].value()) + str(self.dict_envVar[key][1].value())] = [self.dict_envVar[key][0].value(), self.dict_envVar[key][1].value()]
                else:
                    dict_envVar[key.currentText()] = [self.dict_envVar[key][0].value(), self.dict_envVar[key][1].value()]
            else:
                if key.currentText() in dict_envVar:
                    dict_envVar[key.currentText() + ' - '+self.dict_envVar[key][2].currentText()] = self.dict_envVar[key][2].currentText()
                else:
                    dict_envVar[key.currentText()] = self.dict_envVar[key][2].currentText()
        self.list_for_rules_dict.append(dict_envVar)


    def updateRuleDescription(self, writtenRule = None): #TODO get the description to be gramatically correct
        """ Writes a common language description string of the rule and either returns it or fills it in for a QLabel"""
        #rule type
        rule_type_string = ' [no rule type selected] '
        if self.comboBox_rule.currentText() == '(Re)place':
            rule_type_string = ' to be placed on '
        elif self.comboBox_rule.currentText() == 'Encroach':
            rule_type_string = ' to encroach by ' + str(self.spinBox_nOfDistance.value()) + ' map units on '
        elif self.comboBox_rule.currentText() == 'Adjacent':
            rule_type_string = ' to be placed ' + str(self.spinBox_nOfDistance.value()) + ' map units adjacent to '
        elif self.comboBox_rule.currentText() == 'Extent':
            rule_type_string = ' to be placed on '
        #vegetation community/ies
        prev_veg_com_string = ' [no prev veg com selected] '
        if self.radioButton_any.isChecked():
            prev_veg_com_string = 'any vegetation community'
        elif not self.list_prevVegCom:
            if self.comboBox_prevVegCom.currentText() == 'Empty':
                prev_veg_com_string = 'only points with no previously assigned vegetation community'
            else:
                prev_veg_com_string = self.comboBox_prevVegCom.currentText() + ' '
        else:
            prev_veg_com_string = self.comboBox_prevVegCom.currentText()
            for index in range(len(self.list_prevVegCom)):
                if index != len(self.list_prevVegCom)-1:
                    prev_veg_com_string += ', ' + self.list_prevVegCom[index].currentText()
                if index == len(self.list_prevVegCom)-1:
                    prev_veg_com_string += ' and ' + self.list_prevVegCom[index].currentText()
        #environmental variables
        env_var_string = '[no environmental variable selected]'
        if len(self.dict_envVar) == 0:
            if self.comboBox_envVar.currentText() == 'Empty':
                env_var_string = ' regardless of environmental variables'
            elif self.comboBox_category.currentText() == '':
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is between ' + \
                str(self.doubleSpin_rangeMin.value()) + ' and ' +str(self.doubleSpin_rangeMax.value()) + ' '
            else:
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is '+ self.comboBox_category.currentText() + ', '
        else:
            if self.comboBox_category.currentText() == '':
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is between ' + \
                str(self.doubleSpin_rangeMin.value()) + ' and ' +str(self.doubleSpin_rangeMax.value()) + ' '
            else:
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is '+ self.comboBox_category.currentText()+ ', '
            counter = 1
            for key in self.dict_envVar:
                if counter != len(self.dict_envVar):
                    if self.dict_envVar[key][2].currentText() != '':
                        env_var_string += key.currentText() + ' is ' + self.dict_envVar[key][2].currentText() + ', '
                        counter += 1
                    else:
                        env_var_string += key.currentText() + ' is between ' + str(self.dict_envVar[key][0].value()) + \
                                            ' and ' + str(self.dict_envVar[key][1].value()) + ', '
                        counter += 1

                else:
                    if self.dict_envVar[key][2].currentText() != '':
                        env_var_string += 'and ' + key.currentText() + ' is ' +\
                                          self.dict_envVar[key][2].currentText()
                    else:
                        env_var_string += 'and ' + key.currentText() + ' is between ' \
                                          + str(self.dict_envVar[key][0].value()) + ' and ' + str(self.dict_envVar[key][1].value())



        rule_string = 'Rule ' + str(self.rule_number) + ': ' + self.comboBox_ruleVegCom.currentText() + ' has ' + \
                      str(self.doubleSpin_chance.value()) + '% chance'+ rule_type_string + prev_veg_com_string + \
                      env_var_string + '.'

        if isinstance(writtenRule, QLabel):
            writtenRule.setText(rule_string)
        else:
            return rule_string
        pass

    def checkIfLegit(self): # TODO not yet functional
        """ Checks whether the all boxes have been filled in the correct way, otherwise aborts making the rule and
        gives a warning popup"""
        self.messageBox = QMessageBox()
        comboBoxes = [self.comboBox_ruleVegCom.currentIndex(),self.comboBox_rule.currentIndex(),self.comboBox_rule.currentIndex(),
                      self.comboBox_envVar.currentIndex()]
        if all(index ==0 for index in comboBoxes)and self.doubleSpin_chance.value() == 100 and self.n_of_envvar ==1 and self.n_of_vegcom ==1:
            self.messageBox.setWindowTitle('Warning')
            self.messageBox.setText('No changes were detected, are you sure you want to use this rule?')
        if self.comboBox_envVar.count() == 1:
            self.messageBox.setWindowTitle("Warning")
            self.messageBox.setText('No environmental variables were detected as input, are you sure you want to use this rule?')
            self.messageBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        #TODO Can probably think of more warnings



class MsaQgisAddTaxonPopup (QtWidgets.QDialog, FORM_CLASS_TAXA):
    def __init__(self, parent=None):
        """Popup Constructor."""
        super(MsaQgisAddTaxonPopup, self).__init__(parent)
        self.setupUi(self)


class MsaQgisAddVegComPopup (QtWidgets.QDialog, FORM_CLASS_VEGCOM):
    """Popup in which data for a new vegetation community can be entered.

    :param taxon_dict : a dictionary that will contain information on the taxa added to the vegcom, in the format of [comboBox_taxa, doubleSpinBox_taxonPercentage]
    :type self.taxon_dict:dict
 """
    def __init__(self, taxonlist, parent=None):
        """Popup Constructor for popup in which data for a new vegetation community can be entered.

        :param taxonlist: List of taxa to be shown in the comboBox dropdown
        :type taxonlist: list
        """
        super(MsaQgisAddVegComPopup, self).__init__(parent)
        self.setupUi(self)
        #events
        self.pushButton_vegComAddSpecies.clicked.connect(self.addVegComTaxonRow)

        #class variables
        self.previous_gridRow = 0
        self.taxon_list = taxonlist
        self.taxon_dict = {} ;  #"""Should be in format of {QComboBox:QDoubleSpinBox}."""

        #add gridlayout to scrollarea
        self.frameWidget_scroll = QFrame(self.scrollArea)
        self.frameWidget_scroll.setLayout(self.gridLayout)
        self.scrollArea.setWidget(self.frameWidget_scroll)

        #set locations of original widgets in grid #TODO this should be possible directly in Qt Designer/ .UI file.
        self.gridLayout.addWidget(self.label_Title, 0, 0, 1, 4)
        self.gridLayout.addWidget(self.label_Name, 1, 0)
        self.gridLayout.addWidget(self.lineEdit_vegComName, 1, 1, 1, 4)
        self.gridLayout.setRowStretch(2, 100) #stretch middle row to maximum possible size
        self.gridLayout.addWidget(self.pushButton_vegComAddSpecies, 3, 0, 1, 4)
        self.gridLayout.addWidget(self.buttonBox_exec, 4, 1, 1, 3)
        self.gridLayout.addWidget(self.buttonBox_exec, 5, 0, 1, 4)

    def addVegComTaxonRow(self):
        """ Adds a new comboBox and doubleSpinBox to be able to add a new taxon to a vegetation community.
        The new widgets are saved in a dictionary for later use.

        :class params: self.previous_gridRow, self.taxon_dict
        :params from UI files: self.gridLayout, self.pushButton)vegComAddSpecies, self.buttonBox_exec
        """
        label = QLabel('Taxon ' + str(int((self.previous_gridRow * 0.5) + 1)), self)
        self.comboBox_taxon = QComboBox()
        self.doubleSpin_taxonPercentage = QDoubleSpinBox()
        # insert the new widgets
        self.gridLayout.addWidget(label, self.previous_gridRow + 2, 0, 1, 4)
        self.gridLayout.addWidget(self.comboBox_taxon, self.previous_gridRow + 3, 0, 1, 3)
        self.gridLayout.addWidget(self.doubleSpin_taxonPercentage, self.previous_gridRow + 3, 3, 1, 2)
        self.gridLayout.setRowStretch(self.previous_gridRow + 2, 0)  # reset stretch of previously stretched row
        self.gridLayout.setRowStretch(self.previous_gridRow + 4, 100)  # set new middle row to maximum stretch
        # move the widgets below to new location
        self.gridLayout.addWidget(self.pushButton_vegComAddSpecies, self.previous_gridRow + 5, 0, 1, 4)
        self.gridLayout.addWidget(self.buttonBox_exec, self.previous_gridRow + 6, 0, 1, 4)
        self.previous_gridRow += 2
        # Fill the comboBox
        self.comboBox_taxon.addItems(self.taxon_list)
        # Create dict of qwidgets to pass to the main dialog
        self.taxon_dict[self.comboBox_taxon] = self.doubleSpin_taxonPercentage


class MsaQgisSaveLoadDialog(QtWidgets.QDialog,FORM_CLASS_SAVELOAD):
    def __init__(self, save_or_load, parent=None):
        """Popup Constructor."""
        super(MsaQgisSaveLoadDialog, self).__init__(parent)
        self.setupUi(self)
        self.save_or_load = save_or_load
        self.setSaveOrLoadText()

    def setSaveOrLoadText(self):
        if self.save_or_load == 'save':
            self.setWindowTitle('MSA QGIS save dialog')
            self.label_title.setText('Which files would you like to save?')
        if self.save_or_load == 'load':
            self.setWindowTitle('MSA QGIS load dialog')
            self.label_title.setText('Which files would you like to load?')
            self.checkBox_humFile.hide()
            self.checkBox_humFile.setChecked(False)
            self.checkBox_loadImageRuleTree.hide()
            self.checkBox_loadImageRuleTree.setChecked(False)


class MsaQgisRuleListPopup(QtWidgets.QDialog,FORM_CLASS_RULELIST):
    def __init__(self, nest_dict_rules, parent=None):
        """Popup Constructor."""
        super(MsaQgisRuleListPopup, self).__init__(parent)
        self.setupUi(self)
        for key in nest_dict_rules:
            self.listWidget_rules.addItem(nest_dict_rules[key][1])

class MsaQgisAddSite(QtWidgets.QDialog,FORM_CLASS_SAMPLESITE):
    def __init__(self, parent=None):
        """Popup Constructor."""
        super(MsaQgisAddSite, self).__init__(parent)
        self.setupUi(self)

class MsaQgisAddPercentPopup(QtWidgets.QDialog,FORM_CLASS_PERCENT):
    def __init__(self,tableWidget_sampleSites, parent=None):
        """Popup Constructor."""
        super(MsaQgisAddPercentPopup, self).__init__(parent)
        self.setupUi(self)
        for row in range(tableWidget_sampleSites.rowCount()):
            sampling_site = tableWidget_sampleSites.item(row, 0).text()
            self.comboBox_samplingPoint.addItem(sampling_site)

class MsaQgisSuccesDialog(QtWidgets.QDialog,FORM_CLASS_SUCCES):
    def __init__(self, parent=None):
        """Popup Constructor."""
        super(MsaQgisSuccesDialog, self).__init__(parent)
        self.setupUi(self)
        self.radioButton_loadX.clicked.connect(self.enableMapsToLoad)
        self.radioButton_loadBest.clicked.connect(self.disableMapsToLoad)
        self.radioButton_loadFitted.clicked.connect(self.disableMapsToLoad)
        self.radioButton_loadAll.clicked.connect(self.disableMapsToLoad)
        self.radioButton_doNotLoad.clicked.connect(self.disableMapsToLoad)

    def enableMapsToLoad(self):
        self.spinBox_loadX.setEnabled(True)
    def disableMapsToLoad(self):
        self.spinBox_loadX.setEnabled(False)

class MsaQgisRunDialog(QtWidgets.QDialog,FORM_CLASS_RUN):
    def __init__(self, check_state, input_state, parent=None):
        """Popup Constructor."""
        super(MsaQgisRunDialog, self).__init__(parent)
        self.setupUi(self)
        self.run_type = -1

        # Events
        self.radioButton_pointSample.clicked.connect(self.enableButtonBox)
        self.radioButton_basemap.clicked.connect(self.enableButtonBox)
        self.radioButton_msaThoughtExperiment.clicked.connect(self.enableButtonBox)
        self.radioButton_msaReconstruction.clicked.connect(self.enableButtonBox)
        self.mQgsFileWidget.fileChanged.connect(self.enableButtonBox)
        self.radioButton_pointSample.clicked.connect(self.changeRunType)
        self.radioButton_basemap.clicked.connect(self.changeRunType)
        self.radioButton_msaThoughtExperiment.clicked.connect(self.changeRunType)
        self.radioButton_msaReconstruction.clicked.connect(self.changeRunType)
        self.mQgsFileWidget.fileChanged.connect(self.checkIfPathLegit)

        #enable only run_types that are able to be run
        if check_state >= 0:
            self.radioButton_pointSample.setEnabled(True)
            if check_state >=1:
                self.radioButton_basemap.setEnabled(True)
                if check_state >=2:
                    self.radioButton_msaThoughtExperiment.setEnabled(True)
                    if check_state >=3:
                        self.radioButton_msaReconstruction.setEnabled(True)
        if input_state !=0:
            self.radioButton_pointSample.setEnabled(False)
        if input_state ==2:
            self.radioButton_basemap.setEnabled(False)

    def checkIfPathLegit(self):
        """Checks if the file path given in the file widget has been filled, and if so, if it points to an existing
        directory

        :params from UI: self.mQgsFileWidget

        :returns: True if path is legit and can be used, False if not
        :rtype: bool"""
        #check if file path has been filled
        if self.mQgsFileWidget.filePath() != '':
            #check if file path exists on OS
            if not os.path.exists(self.mQgsFileWidget.filePath()):
                iface.messageBar().pushMessage('Directory not found on device', level=1)
                return False
            else:
                return True
        else:
            return False

    def enableButtonBox(self):
        """Checks if all of the input is legit, and if yes, enables the ok button"""
        if (self.radioButton_pointSample.isChecked() or self.radioButton_basemap.isChecked()
                or self.radioButton_msaThoughtExperiment.isChecked() or self.radioButton_msaReconstruction.isChecked()):
            path_state = self.checkIfPathLegit()
            self.buttonBox_ok.setEnabled(path_state)
        else:
            self.buttonBox_ok.setEnabled(False)

    def changeRunType(self):
        """Changes the run type based on which radiobutton is checked.
        0 = only point sample
        1 = only basemap
        2 = run MSA without fit (thought experiment)
        3 = run MSA with fit (full reconstruction)
        -1 = invalid input"""

        if self.radioButton_pointSample.isChecked():
            self.run_type = 0
        elif self.radioButton_basemap.isChecked():
            self.run_type = 1
        elif self.radioButton_msaThoughtExperiment.isChecked():
            self.run_type = 2
        elif self.radioButton_msaReconstruction.isChecked():
            self.run_type = 3
        else:
            self.run_type = -1

