# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MsaQgisDialog
                                 A QGIS plugin
 This plugin allows the use of the Multi Scenario Approach in QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Thya van den Berg
        email                : w.b.van-den-berg-2020@hull.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import re

from PyQt5.QtWidgets import QTableWidgetItem, QWidget, QLineEdit, QLabel, QVBoxLayout, QComboBox, QGridLayout, \
    QDoubleSpinBox, QFrame, QRadioButton, QHBoxLayout, QPushButton, QSpacerItem, QScrollArea, QCheckBox, QMessageBox, \
    QSizePolicy
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import iface
from qgis.core import *


from .MSA_QGIS_custom_widget_rule_tree import RuleTreeWidget


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_base.ui'))
FORM_CLASS_TAXA, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_popup_taxa.ui'))
FORM_CLASS_VEGCOM, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_popup_vegcom.ui'))
FORM_CLASS_RULES, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_popup_add_rule.ui'))
FORM_CLASS_RULE_TREE, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'MSA_QGIS_dialog_add_to_rule_tree.ui'))

### Main dialog window


class MsaQgisDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(MsaQgisDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # class variables
        self.vegcom_row_count = 0
        self.vegcom_column_count = 1
        self.extent = None
        self.rule_number = 0
        self.selected_rule = None

        # class lists & dictionaries
        self.list_cb_rule_veg_com = []
        self.list_cb_env_var = []
        self.list_cb_rule_type = []
        self.nest_dict_rules = {}    # {'rule number': [rule_number(int), vegcom(str), chance(float), n of prev vegcoms(int),
                                # n of env vars(int), # all(bool),
                                # prevvegcom (QTableItem), AND(bool), OR(bool), nextprevvegcom...etc,
                                # envvar (QtableItem), AND(bool), OR(bool), next envvar...etc}
        self.dict_ruleTreeWidgets = {}

        # UI setup
        self.qgsFileWidget_importHandbag.setFilter('*.hum')
        self.ruleTreeGrid = QGridLayout()
        self.ruleTreeGrid.setVerticalSpacing(1)
        self.frame_ruleTree.setLayout(self.ruleTreeGrid)


        # events
        self.mExtentGroupBox.setMapCanvas(iface.mapCanvas())
        #self.mExtentGroupBox.setOutputExtentFromDrawOnCanvas() #for some reason causes really weird behaviour.
        # Q asked on GIS stackexchange
        self.mExtentGroupBox.extentChanged.connect(self.setExtent)
        self.getFieldsandBands(self.tableWidget_vector, self.tableWidget_raster)
        self.tableWidget_vector.itemSelectionChanged.connect(lambda: self.updateSelectedRows(self.tableWidget_selected,
                                                                                      self.tableWidget_vector))
        self.tableWidget_raster.itemSelectionChanged.connect(lambda: self.updateSelectedRows(self.tableWidget_selRaster,
                                                                                             self.tableWidget_raster))
        self.pushButton_newTaxa.clicked.connect(self.addNewTaxon)
        self.pushButton_newVegCom.clicked.connect(self.addNewVegCom)
        self.pushButton_removeTaxa.clicked.connect(self.removeTaxaEntry)
        self.pushButton_removeVegCom.clicked.connect(self.removeVegComEntry)
        self.pushButton_importHandbag.clicked.connect(self.loadHandbagFile)
        self.pushButton_addRule.clicked.connect(self.addNewRule)
        self.pushButton_ruleBelow.clicked.connect(self.addRuleToRuleTree)
        #TODO close all assocated windows when main dialog is closed



    def setExtent(self):
        """Attaches the extent given by the user to a variable, and updates the 'current extent'
        so that the input can be used in further analysis"""
        self.extent = self.mExtentGroupBox.outputExtent()
        self.mExtentGroupBox.setCurrentExtent(self.extent, self.mExtentGroupBox.outputCrs())

    def getFieldsandBands(self, tableWidget_vector, tableWidget_raster):
        """Fills a table widget with all fields from vector polygon layers and all bands from raster layers currently
        loaded into the QGIS interface"""
        tableWidget_vector.clear()
        row_count = 0
        column_count = 0
        tableWidget_vector.setRowCount(row_count + 1)

        tableWidget_raster.clear()
        ras_row_count = 0
        ras_column_count = 0
        tableWidget_raster.setRowCount(ras_row_count + 1)

        for lyr_nr in range(iface.mapCanvas().layerCount()):
            layer = iface.mapCanvas().layer(lyr_nr)
            if (layer.type() == layer.VectorLayer) and (layer.geometryType() == QgsWkbTypes.PolygonGeometry):
                data_provider = layer.dataProvider()
                for field in data_provider.fields():
                    tableWidget_vector.setItem(row_count, column_count, QTableWidgetItem(layer.name()))
                    column_count +=1
                    tableWidget_vector.setItem(row_count, column_count, QTableWidgetItem(field.name()))
                    row_count += 1
                    tableWidget_vector.setRowCount(row_count + 1)
                    column_count -= 1
            elif layer.type() == layer.RasterLayer:
                for band in range(layer.bandCount()):
                    tableWidget_raster.setItem(ras_row_count, ras_column_count, QTableWidgetItem(layer.name()))
                    ras_column_count += 1
                    tableWidget_raster.setItem(ras_row_count, ras_column_count, QTableWidgetItem(layer.bandName(band + 1)))
                    ras_row_count += 1
                    tableWidget_raster.setRowCount(ras_row_count + 1)
                    ras_column_count -= 1
            else:
                continue

            tableWidget_vector.setHorizontalHeaderLabels(['Layers', 'Fields'])
            tableWidget_raster.setHorizontalHeaderLabels(['Layers', 'Bands'])
        tableWidget_vector.setRowCount(row_count)
        tableWidget_raster.setRowCount(ras_row_count)

    def updateSelectedRows(self, tableWidget_selection, tableWidget_list):
        """ Updates a table widget with the rows selected in another table widget"""
        # selectionTable = self.tableWidget_selected
        # listTable = self.tableWidget_vector
        tableWidget_selection.setRowCount(len(tableWidget_list.selectionModel().selectedRows()))
        row_count_sel = 0

        for row in range(tableWidget_list.rowCount()):
            if tableWidget_list.item(row, 0).isSelected():
                tableWidget_selection.setItem(row_count_sel,
                                              0,
                                              QTableWidgetItem(tableWidget_list.item(row, 0)))
                tableWidget_selection.setItem(row_count_sel,
                                              1,
                                              QTableWidgetItem(tableWidget_list.item(row, 1)))
            else:
                continue
            row_count_sel += 1

    def addNewTaxon(self):
        """ Adds a new pollen taxon to the list of taxa by opening a pop-up in which the taxon short and full name,
        fall speed and relative pollen productivity can be given"""
        self.taxonPopup = MsaQgisAddTaxonPopup()
        self.taxonPopup.show()
        result = self.taxonPopup.exec_()
        # runs when apply is clicked on the add new taxon popup
        if result:
            # Get filled in values
            taxon_short_name = self.taxonPopup.lineEdit_taxonShortName.text()
            taxon_full_name = self.taxonPopup.lineEdit_taxonFullName.text()
            taxon_fall_speed = self.taxonPopup.doubleSpinBox_taxonFallSpeed.value()
            taxon_rpp = self.taxonPopup.doubleSpinBox_taxonRPP.value()
            # Check if entry is valid and add to table
            if taxon_short_name and taxon_full_name and taxon_fall_speed and taxon_rpp:
                row_count = self.tableWidget_taxa.rowCount()
                self.tableWidget_taxa.setRowCount(row_count+1)
                self.tableWidget_taxa.setItem(row_count, 0, QTableWidgetItem(taxon_short_name))
                self.tableWidget_taxa.setItem(row_count, 1, QTableWidgetItem(taxon_full_name))
                self.tableWidget_taxa.setItem(row_count, 2, QTableWidgetItem(str(taxon_fall_speed)))
                self.tableWidget_taxa.setItem(row_count, 3, QTableWidgetItem(str(taxon_rpp)))
            else:
                iface.messageBar().pushMessage('Missing value in add new taxon, '
                                                    'please try again', level=1)

    def addNewVegCom(self):
        """ Adds a new vegetation community to the list of communities by opening a pop-up in which a list of species
         and their percentages, as well as a new community name can be given"""
        #pass list of taxa to the popup and open it
        tableWidget_taxa = self.tableWidget_taxa
        item_list = [tableWidget_taxa.item(row,0).text() for row in range(tableWidget_taxa.rowCount())]
        self.veg_com_popup = MsaQgisAddVegComPopup(item_list)
        tableWidget_vegCom = self.tableWidget_vegCom

        #add entries to table
        result = self.veg_com_popup.exec_()
        if result:
            self.vegcom_row_count += 1
            tableWidget_vegCom.setRowCount(self.vegcom_row_count)
            tableWidget_vegCom.setItem(self.vegcom_row_count - 1, 0, QTableWidgetItem(
                self.veg_com_popup.lineEdit_vegComName.text()))

            #Check if a taxon already had a column, add new column only for a new taxon
            #Create list of taxa that already have a column
            header_list = [tableWidget_vegCom.horizontalHeaderItem(column).text() for column in range(1, tableWidget_vegCom.columnCount())]
            for taxon in range(len(self.veg_com_popup.vegcom_taxon_combo_list)):
                if self.veg_com_popup.vegcom_taxon_combo_list[taxon].currentText() in header_list:
                    # get column number of named column
                    for column in range(tableWidget_vegCom.columnCount()):
                        header_text = tableWidget_vegCom.horizontalHeaderItem(column).text()
                        if header_text == self.veg_com_popup.vegcom_taxon_combo_list[taxon].currentText():
                            tableWidget_vegCom.setItem(self.vegcom_row_count - 1, column, QTableWidgetItem(
                                str(self.veg_com_popup.vegcom_taxon_double_list[taxon].value())))
                    # add value at right location to that column
                    pass
                elif self.veg_com_popup.vegcom_taxon_combo_list[taxon] not in header_list:
                    self.vegcom_column_count += 1
                    self.tableWidget_vegCom.setColumnCount(self.vegcom_column_count)
                    # set header of new column
                    tableWidget_vegCom.setHorizontalHeaderItem(self.vegcom_column_count - 1, QTableWidgetItem(
                                self.veg_com_popup.vegcom_taxon_combo_list[taxon].currentText()))
                    # add value to new column
                    tableWidget_vegCom.setItem(self.vegcom_row_count - 1, self.vegcom_column_count - 1, QTableWidgetItem(
                        str(self.veg_com_popup.vegcom_taxon_double_list[taxon].value())))
                else:
                    print('error in creating veg com columns')

    def removeTaxaEntry(self):
        """ Removes selected entries from a table with a pop-up warning"""
        # popup
        pass #TODO create pop-up warning


        #get selection
        tableWidget_taxa = self.tableWidget_taxa
        for row in tableWidget_taxa.selectionModel().selectedRows():
            tableWidget_taxa.removeRow(row.row())

    def removeVegComEntry(self):
        """ Removes selected entries from a table with a pop-up warning"""
        #Popup
        pass #TODO create pop-up warning


        #remove row
        tableWidget_vegCom = self.tableWidget_vegCom
        columns_to_remove = []

        if tableWidget_vegCom.selectionModel().selectedRows():
            for row in tableWidget_vegCom.selectionModel().selectedRows():
                tableWidget_vegCom.removeRow(row.row())
                self.vegcom_row_count -= 1
        #remove columns that no longer contain data after the row was removed
        for column in range(1,tableWidget_vegCom.columnCount()):
            item_list = []
            for row in range(tableWidget_vegCom.rowCount()):
                if tableWidget_vegCom.item(row,column):
                    item_list.append(tableWidget_vegCom.item(row,column))
            if not item_list:
                columns_to_remove.append(column)
            else:
                continue
        for list_item in columns_to_remove:
            tableWidget_vegCom.removeColumn(list_item)
            self.vegcom_column_count -= 1
            tableWidget_vegCom.setColumnCount(self.vegcom_column_count)

    def loadHandbagFile(self):
        """
        Loads a HUMPOL handbag (.hum) file into the software. This fills in the data (if specified in the file) for:
        Taxa
        Communities
        Sample points
        Windroses
        Metadata
        Notes
        Compatible with the HUMPOL suite (Bunting & Middleton 2005) and LandPolFlow (Bunting & Middleton 2009)
        """
        #TODO sample points, windrose data, metadata, notes
        file_name = self.qgsFileWidget_importHandbag.filePath()
        tableWidget_vegCom = self.tableWidget_vegCom
        if not os.path.isfile(file_name):
            print('file does not exist')
        else:
            with open(file_name) as file:
                for line in file:
                    if line[0] == '1':
                        if int(line[:4]) >= 1100:
                            line = line[5:]
                            line_list = list(re.split('\t|\n', line))
                            row_count = self.tableWidget_taxa.rowCount()
                            self.tableWidget_taxa.setRowCount(row_count + 1)
                            self.tableWidget_taxa.setItem(row_count, 0, QTableWidgetItem(line_list[0]))
                            self.tableWidget_taxa.setItem(row_count, 1, QTableWidgetItem(line_list[1]))
                            self.tableWidget_taxa.setItem(row_count, 2, QTableWidgetItem(str(line_list[2])))
                            self.tableWidget_taxa.setItem(row_count, 3, QTableWidgetItem(str(line_list[3])))
                    elif line[0] == '2': #communities
                        # skip community names (TODO but what to do if a handbag file has multiple community files?)
                        if 2200 <= int(line[:4]) < 2300:
                            line = line[7:]
                            line = line.replace('\n','')
                            self.vegcom_row_count += 1
                            tableWidget_vegCom.setRowCount(self.vegcom_row_count)
                            tableWidget_vegCom.setItem(self.vegcom_row_count - 1, 0, QTableWidgetItem(
                                line))
                        elif int(line[:4]) >= 2300:
                            line = line[5:]
                            line_list = list(re.split('\t|\n', line))
                            # Only create a new column if the header does not yet exist note: this is a duplicate from addNewVegCom
                            header_list = [tableWidget_vegCom.horizontalHeaderItem(column).text() for column in
                                           range(1, tableWidget_vegCom.columnCount())]
                            if line_list[0] in header_list:
                                # get column number of named column
                                for column in range(tableWidget_vegCom.columnCount()):
                                    header_text = tableWidget_vegCom.horizontalHeaderItem(column).text()
                                    if header_text == line_list[0]:
                                        tableWidget_vegCom.setItem(self.vegcom_row_count - 1, column,
                                                                   QTableWidgetItem(line_list[1]))
                                # add value at right location to that column
                                pass
                            elif line_list[0] not in header_list:
                                self.vegcom_column_count += 1
                                self.tableWidget_vegCom.setColumnCount(self.vegcom_column_count)
                                # set header of new column
                                tableWidget_vegCom.setHorizontalHeaderItem(self.vegcom_column_count - 1,
                                                                           QTableWidgetItem(line_list[0]))
                                # add value to new column
                                tableWidget_vegCom.setItem(self.vegcom_row_count - 1, self.vegcom_column_count - 1,
                                                           QTableWidgetItem(
                                                               str(line_list[1])))
                            else:
                                print('error in creating veg com columns')

                        pass
                    elif line[0] == '3': #sample points
                        pass

                file.close()

    def addNewRule(self):
        """ Allows the dynamic adding of new rules under the rules tab in the main dialog UI."""

        self.add_rule_popup = MsaQgisAddRulePopup(self.rule_number, self.tableWidget_vegCom,
                                                  self.tableWidget_selected, self.tableWidget_selRaster)
        self.add_rule_popup.show()

        if self.add_rule_popup.exec_():
            self.nest_dict_rules['Rule ' + str(self.rule_number)] = self.add_rule_popup.dict_rules_list
            self.listWidget_rules.addItem(self.nest_dict_rules['Rule ' + str(self.rule_number)][1])
            self.rule_number += 1
            # add the rule to the rule list

    def addRuleToRuleTree(self, selected_rule = None, rule_tree_type = 'Insert Above'): # TODO make universally applicable
        # check if there are any rules in the rule dictionary
        if self.nest_dict_rules:
            #determine which of the rules in the rule tree is selected
            for key in self.dict_ruleTreeWidgets:
                if self.dict_ruleTreeWidgets[key].isSelected:
                    selected_rule = key
                    print(selected_rule)
            x_position_for_spoilerplate = self.scrollArea_ruleTree.x() + self.tab_top.x() + self.x()
            y_position_for_spoilerplate = self.scrollArea_ruleTree.y() + self.tab_top.y() + self.y()
            # Determine rule ID
            if selected_rule >= 1:
                if self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets: # NOTE max number of branches possible is 10, but can adjust for higher by adding 00 or 000 in other option.
                    rule_id = max(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) + 1
                else:
                    rule_id = int(str(self.dict_ruleTreeWidgets[selected_rule].order_id)+str(0))
            else:
                if not self.dict_ruleTreeWidgets:
                    rule_id = 1
                else:
                    iface.messageBar().pushMessage("Error", "select a rule to add a new rule to the rule tree",
                                                   level=1)  # TODO replace with popup once I have the energy
                    return #exit function
            # Determine location of rule in grid
            if self.dict_ruleTreeWidgets:
                if selected_rule:
                    if len(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets) > 0:
                        prev_rule = self.dict_ruleTreeWidgets[max(self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets)]
                        grid_index = self.ruleTreeGrid.indexOf(prev_rule)
                        n_row = self.ruleTreeGrid.getItemPosition(grid_index)[0]
                        n_column = self.ruleTreeGrid.getItemPosition(grid_index)[1] +1
                    else:
                        grid_index = self.ruleTreeGrid.indexOf(self.dict_ruleTreeWidgets[selected_rule])
                        n_row = self.ruleTreeGrid.getItemPosition(grid_index)[0] + 1
                        n_column = self.ruleTreeGrid.getItemPosition(grid_index)[1]
            else:
                n_row = 0
                n_column = 0

            #make and place widget
            if selected_rule >= 1:
                ruleTreeWidget = RuleTreeWidget(self.nest_dict_rules,rule_id, selected_rule, main_dialog_x = x_position_for_spoilerplate, # TODO get order_id and list_previousRuleTreeWidgets form selected ruleTreeWidget
                                            main_dialog_y = y_position_for_spoilerplate)
            else:
                ruleTreeWidget = RuleTreeWidget(self.nest_dict_rules,rule_id, main_dialog_x = x_position_for_spoilerplate, # TODO get order_id and list_previousRuleTreeWidgets form selected ruleTreeWidget
                                            main_dialog_y = y_position_for_spoilerplate)

            self.ruleTreeGrid.addWidget(ruleTreeWidget,n_row, n_column)
            self.ruleTreeGrid.setRowStretch(n_row+1, 1)
            self.ruleTreeGrid.setRowStretch(n_row, 0)
            # add widget to dict of existing widgets
            self.dict_ruleTreeWidgets[ruleTreeWidget.order_id] = ruleTreeWidget
            # find previous rule tree widget and add this widget to its next_ruleTreeWidgets
            if selected_rule >= 1:
                self.dict_ruleTreeWidgets[selected_rule].next_ruleTreeWidgets.append(rule_id)
            # displace widgets in same column
            for row in range(n_row-1, 0, -1):
                item = self.ruleTreeGrid.itemAtPosition(row,n_column)
                if item:
                    widget = item.widget()
                    print('there is an item at this position: ', row, ', ',  n_column)
                    if isinstance(widget,QWidget) and not isinstance(widget,RuleTreeWidget):
                        print('it is an empty QWidget')
                        self.ruleTreeGrid.replaceWidget(widget,QWidget())
                        self.ruleTreeGrid.addWidget(widget, row, n_column+1)
                    elif rule_id in widget.next_ruleTreeWidgets:
                        print('but it is the previous ruleTreeWidget')
                        break
                    else:
                        print('and it is not the previous ruleTreeWidget')
                        self.ruleTreeGrid.replaceWidget(widget,QWidget())
                        self.ruleTreeGrid.addWidget(widget, row, n_column+1)


        else:
            iface.messageBar().pushMessage("Error", "There are no rules to add", level = 1) # TODO replace with popup once I have the energy
            return # exit function

class MsaQgisAddRulePopup (QtWidgets.QDialog, FORM_CLASS_RULES):
    def __init__(self, rule_number, tableWidget_vegCom, tableWidget_selected, tableWidget_selRaster, parent = None):
        """Popup Constructor"""
        super(MsaQgisAddRulePopup, self).__init__(parent)
        self.setupUi(self)

        # Class variables
        self.rule_number = rule_number
        self.tableWidget_vegCom = tableWidget_vegCom
        self.tableWidget_selected = tableWidget_selected
        self.tableWidget_selRaster = tableWidget_selRaster
        self.n_of_vegcom = 1
        self.n_of_envvar = 1

        # Dictionaries & lists
        self.list_prevVegCom = []
        self.dict_envVar = {}
        self.dict_rules_list = []

        # Set (in)visible
        self.label_rangeMinMax.hide()
        self.doubleSpin_rangeMin.hide()
        self.doubleSpin_rangeMax.hide()
        self.label_category.hide()
        self.comboBox_category.hide()
        self.label_nOfPoints.hide()
        self.spinBox_nOfPoints.hide()
        self.comboBox_condTypePrevVeg.hide()
        self.label_condTypePrevVeg.hide()
        self.comboBox_condTypeEnvVar.hide()
        self.label_condTypeEnvVar.hide()

        # Events
        self.pushButton_condVegCom.clicked.connect(self.addConditionalPrevVegCom)
        self.pushButton_condEnvVar.clicked.connect(self.addConditionalEnvVar)
        self.comboBox_envVar.currentTextChanged.connect(lambda: self.addRangeOrCatToEnvVar(self.comboBox_envVar,
                                                                                   self.label_rangeMinMax,
                                                                                   self.doubleSpin_rangeMin,
                                                                                   self.doubleSpin_rangeMax,
                                                                                   self.label_selectEnvVar,
                                                                                   self.label_category,
                                                                                   self.comboBox_category))
        self.comboBox_rule.currentTextChanged.connect(self.addNofPointsToRule)
        self.accepted.connect(self.updateDictionary)
        self.pushButton_checkRule.clicked.connect(lambda: self.updateRuleDescription(self.label_writtenRule))
        #TODO give warnings for empty boxes
        self.buttonBox.accepted.connect(self.checkIfLegit)

        # Fill comboBoxes
        for row in range(self.tableWidget_vegCom.rowCount()):
            self.comboBox_ruleVegCom.addItem(self.tableWidget_vegCom.item(row, 0).text())
            self.comboBox_prevVegCom.addItem(self.tableWidget_vegCom.item(row, 0).text())
        for row in range(self.tableWidget_selected.rowCount()):
            self.comboBox_envVar.addItem(self.tableWidget_selected.item(row, 0).text()+' - '+self.tableWidget_selected.item(row,1).text())
        for row in range(self.tableWidget_selRaster.rowCount()):
            self.comboBox_envVar.addItem(self.tableWidget_selRaster.item(row, 0).text()+' - '+self.tableWidget_selRaster.item(row,1).text())
        #set min & max size for comboBox envVar
        self.label_writtenRule.setText('Rule '+str(rule_number))


    def addRangeOrCatToEnvVar(self, env_var, label_range, rangeMin, rangeMax,label_noChoice, label_category, category):
        """ An option to fill in range for the environmental variable appears if the variable is numerical"""
        #get layer associated with current item
        category.clear()
        rangeMin.clear()
        rangeMax.clear()
        if env_var.currentText() == 'Empty':
            label_range.hide()
            rangeMin.hide()
            rangeMax.hide()
            label_noChoice.show()
            label_category.hide()
            category.hide()
        else:
            layer_name = list(re.split(' - ', env_var.currentText()))[0]
            field_or_band = list(re.split(' - |:', env_var.currentText()))[1]
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]
            data_provider = layer.dataProvider()
            if (layer.type() == layer.VectorLayer):
                field_index = data_provider.fieldNameIndex(field_or_band)
                field = data_provider.fields().at(field_index)
                if field.type() == 10 or field.type() == 1: # 10 is str, 1 is bool TODO check if these and int & double are the only options
                    label_range.hide()
                    rangeMin.hide()
                    rangeMax.hide()
                    label_noChoice.hide()
                    label_category.show()
                    category.show()
                    #get categories from fields
                    feat_field = 0
                    for feat in data_provider.getFeatures():
                        if feat_field == 0:
                            feat_field = feat.attribute(field.name())
                            category.addItem(str(feat_field))
                        elif feat_field == feat.attribute(field.name()):
                            pass
                        else:
                            feat_field = feat.attribute(field.name())
                            category.addItem(str(feat_field))

                else:
                    label_range.show()
                    rangeMin.show()
                    rangeMax.show()
                    label_noChoice.hide()
                    label_category.hide()
                    category.hide()
                    #get range from fields
                    rangeMin.setMinimum(data_provider.minimumValue(field_index))
                    rangeMin.setMaximum(data_provider.maximumValue(field_index))
                    rangeMax.setMinimum(data_provider.minimumValue(field_index))
                    rangeMax.setMaximum(data_provider.maximumValue(field_index))
                pass
            elif layer.type() == layer.RasterLayer:
                band_nr = int(list(re.split(' ',field_or_band))[1]) #TODO check if the format 'band [number]:' is consistent for all raster layers!
                if data_provider.dataType(band_nr) != 0: # Checks if band contains numerical data
                    label_range.show()
                    rangeMin.show()
                    rangeMax.show()
                    label_noChoice.hide()
                    label_category.hide()
                    category.hide()
                    #get range from bands
                    stats = data_provider.bandStatistics(band_nr, QgsRasterBandStats.All)
                    minimum_value = stats.minimumValue
                    maximum_value = stats.maximumValue
                    rangeMin.setMinimum(minimum_value)
                    rangeMin.setMaximum(maximum_value)
                    rangeMax.setMinimum(minimum_value)
                    rangeMax.setMaximum(maximum_value)
                else: #NOTE honestly, currently not necessary, unless there is a way to find out if a raster layer is actually categorical...
                    label_range.hide()
                    rangeMin.hide()
                    rangeMax.hide()
                    label_noChoice.hide()
                    label_category.show()
                    category.show()
                    #get categories from band TODO don't think there is currently a way to do this
        pass


    def addNofPointsToRule(self):
        """ Makes a spin box appear when adjacent or encroach is selected under choose rule type"""
        if self.comboBox_rule.currentText() == 'Encroach' or self.comboBox_rule.currentText() == 'Adjacent':
            self.label_nOfPoints.show()
            self.spinBox_nOfPoints.show()
        else:
            self.label_nOfPoints.hide()
            self.spinBox_nOfPoints.hide()
        pass

    def addConditionalPrevVegCom(self):
        """ A comboBox appears from which the user can choose whether they want to apply OR or AND rules, and an
        extra row where an additional previous vegetation community can be chosen appears """
        # combobox and/or
        self.comboBox_condTypePrevVeg.show()
        self.label_condTypePrevVeg.show()
        self.radioButton_all.hide()
        self.radioButton_all.setChecked(False)
        # create new widgets
        comboBox_prevVegCom = QComboBox()
        label_prevVegCom = QLabel()
        pushButton_rmPrevVegCom = QPushButton('Remove conditional')

        #fill combobox
        comboBox_prevVegCom.addItem('Empty')
        for row in range(self.tableWidget_vegCom.rowCount()):
            comboBox_prevVegCom.addItem(self.tableWidget_vegCom.item(row, 0).text())
        #create layouts
        vLayout_prevVegCom = QVBoxLayout()
        vLayout_removeButton = QVBoxLayout()
        hLayout_prevVegCom = QHBoxLayout()
        widget_total = QWidget()
        #fill layouts
        vLayout_prevVegCom.addWidget(label_prevVegCom)
        vLayout_prevVegCom.addWidget(comboBox_prevVegCom)
        vLayout_removeButton.addWidget(pushButton_rmPrevVegCom)
        vLayout_removeButton.insertStretch(0)
        hLayout_prevVegCom.addLayout(vLayout_prevVegCom)
        hLayout_prevVegCom.addLayout(vLayout_removeButton)
        widget_total.setLayout(hLayout_prevVegCom)

        self.vLayout_total.insertWidget(self.n_of_vegcom + 1, widget_total)
        #event for subsequent remove
        pushButton_rmPrevVegCom.clicked.connect(lambda *args, widget = widget_total:
                                                self.removeConditionalPrevVegCom(widget_total))

        self.n_of_vegcom +=1
        self.list_prevVegCom.append(comboBox_prevVegCom)

        pass

    def removeConditionalPrevVegCom(self, widget_to_remove):
        """ Removes selected conditionals that were added to the UI. If all but the start prev veg com are gone, the all
         radioButton reappears and choose condition type comboBox disappears"""
        widget_to_remove.deleteLater()
        self.n_of_vegcom -=1

        # TODO make it delete from list

        if self.n_of_vegcom == 1:
            self.comboBox_condTypePrevVeg.hide()
            self.label_condTypePrevVeg.hide()
            self.radioButton_all.show()

    def addConditionalEnvVar(self):
        """ A comboBox appears from which the user can choose whether the want to apply OR or AND rules, and an
        extra row where an additional environmental variable can be chosen appears"""
        self.comboBox_condTypeEnvVar.show()
        self.label_condTypeEnvVar.show()

        # create new widgets
        label_envVar = QLabel()
        comboBox_envVar = QComboBox()
        label_range = QLabel('Range')
        doubleSpin_rangeMin = QDoubleSpinBox()
        doubleSpin_rangeMax = QDoubleSpinBox()
        label_noChoice = QLabel('[No environmental variable selected]')
        label_chooseCategory = QLabel('Category')
        comboBox_category = QComboBox()
        pushButton_rmPrevVegCom = QPushButton('Remove conditional')

        # fill combobox
        comboBox_envVar.addItem('Empty')
        for row in range(self.tableWidget_selected.rowCount()):
            comboBox_envVar.addItem(self.tableWidget_selected.item(row, 0).text()+' - '+self.tableWidget_selected.item(row,1).text())
        for row in range(self.tableWidget_selRaster.rowCount()):
            comboBox_envVar.addItem(self.tableWidget_selRaster.item(row, 0).text()+' - '+self.tableWidget_selRaster.item(row,1).text())

        # create layouts
        vLayout_envVar = QVBoxLayout()
        vLayout_rangeOrCat = QVBoxLayout()
        hLayout_range = QHBoxLayout()
        vLayout_removeButton = QVBoxLayout()
        hLayout_envVar = QHBoxLayout()
        widget_total = QWidget()

        # fill layouts
        vLayout_envVar.addWidget(label_envVar)
        vLayout_envVar.addWidget(comboBox_envVar)
        vLayout_rangeOrCat.addWidget(label_range)
        hLayout_range.addWidget(doubleSpin_rangeMin)
        hLayout_range.addWidget(doubleSpin_rangeMax)
        vLayout_rangeOrCat.addLayout(hLayout_range)
        vLayout_rangeOrCat.addWidget(label_noChoice)
        vLayout_rangeOrCat.addWidget(label_chooseCategory)
        vLayout_rangeOrCat.addWidget(comboBox_category)
        vLayout_removeButton.addWidget(pushButton_rmPrevVegCom)
        vLayout_removeButton.insertStretch(0)
        hLayout_envVar.addLayout(vLayout_envVar)
        hLayout_envVar.addLayout(vLayout_rangeOrCat)
        hLayout_envVar.addLayout(vLayout_removeButton)
        widget_total.setLayout(hLayout_envVar)
        self.vLayout_total.insertWidget(self.n_of_envvar+2 + self.n_of_vegcom, widget_total)

        # hide
        label_range.hide()
        doubleSpin_rangeMin.hide()
        doubleSpin_rangeMax.hide()
        label_chooseCategory.hide()
        comboBox_category.hide()

        # create signals (to hide/show range/category and to remove later
        comboBox_envVar.currentTextChanged.connect(lambda *args, env_var = comboBox_envVar, label_range = label_range, rangeMin =doubleSpin_rangeMin,
                                                          rangeMax = doubleSpin_rangeMax, label_noChoice = label_noChoice,
                                                          label_category = label_chooseCategory,category = comboBox_category:
                                                   self.addRangeOrCatToEnvVar(env_var, label_range, rangeMin, rangeMax,
                                                                              label_noChoice, label_category, category))
        pushButton_rmPrevVegCom.clicked.connect(lambda *args, widget = widget_total:
                                                self.removeConditionalEnvVar(widget))
        #pass stuff on along to list


        self.n_of_envvar += 1
        self.dict_envVar[comboBox_envVar] = [doubleSpin_rangeMin, doubleSpin_rangeMax, comboBox_category] # cat_range_none(str), rangeMin, rangeMax, category
        pass

    def removeConditionalEnvVar(self, widget):
        """ Removes selected conditionals that were added to the UI. If all but the start env var are gone,
        the choose conditional type comboBox disappears"""

        widget.deleteLater()
        self.n_of_envvar -= 1
        #TODO make it delete from dictionary

        if self.n_of_envvar == 1:
            self.comboBox_condTypeEnvVar.hide()
            self.label_condTypeEnvVar.hide()
            pass

    def updateDictionary(self):
        """ Fills in all of the parameters the user has given in the UI in a list to be added to the dictionary in the
        main dialog"""
        self.dict_rules_list.clear()
        #lists and dicts
        list_prevVegCom = []
        dict_envVar = {}
        # insert from static objects
        self.dict_rules_list.append(self.rule_number)
        self.dict_rules_list.append(self.updateRuleDescription())
        self.dict_rules_list.append(self.comboBox_ruleVegCom.currentText())
        self.dict_rules_list.append(self.comboBox_rule.currentText())
        self.dict_rules_list.append(self.doubleSpin_chance.value())
        self.dict_rules_list.append(self.spinBox_nOfPoints.value())
        self.dict_rules_list.append(self.n_of_vegcom)
        self.dict_rules_list.append(self.comboBox_condTypePrevVeg.currentText())
        self.dict_rules_list.append(self.n_of_envvar)
        self.dict_rules_list.append(self.comboBox_condTypeEnvVar.currentText())
        self.dict_rules_list.append(self.radioButton_all.isChecked())

        # insert from dynamically added widgets
        # previous vegetation communities
        list_prevVegCom.append(self.comboBox_prevVegCom.currentText())
        for vegcoms in self.list_prevVegCom:
            list_prevVegCom.append(vegcoms.currentText())
        self.dict_rules_list.append(list_prevVegCom)
        # environmental variables
        if self.comboBox_category.currentText() == '':
            dict_envVar[self.comboBox_envVar.currentText()] = [self.doubleSpin_rangeMin.value(), self.doubleSpin_rangeMax.value()]
        else:
            dict_envVar[self.comboBox_envVar.currentText()] = self.comboBox_category.currentText()

        for key in self.dict_envVar:
            if self.dict_envVar[key][2].currentText() == '':
                dict_envVar[key.currentText()] = [self.dict_envVar[key][0].value(), self.dict_envVar[key][1].value()]
            else:
                dict_envVar[key.currentText()] = self.dict_envVar[key][2].currentText()
        self.dict_rules_list.append(dict_envVar)


    def updateRuleDescription(self, writtenRule = None): #TODO get the description to be gramatically correct
        """ Writes a common language description string of the rule and either returns it or fills it in for a QLabel"""
        #rule type
        rule_type_string = ' [no rule type selected] '
        if self.comboBox_rule.currentText() == '(Re)place':
            rule_type_string = ' to be placed on '
        elif self.comboBox_rule.currentText() == 'Encroach':
            rule_type_string = ' to encroach by ' + str(self.spinBox_nOfPoints.value()) + ' points on '
        elif self.comboBox_rule.currentText() == 'Adjacent':
            rule_type_string = ' to be placed ' + str(self.spinBox_nOfPoints.value()) + ' points adjacent to '
        elif self.comboBox_rule.currentText() == 'Extent':
            rule_type_string = ' to be placed on '
        #vegetation community/ies
        prev_veg_com_string = ' [no prev veg com selected] '
        if self.radioButton_all.isChecked():
            prev_veg_com_string = 'any vegetation community'
        elif not self.list_prevVegCom:
            if self.comboBox_prevVegCom.currentText() == 'Empty':
                prev_veg_com_string = 'only points with no previously assigned vegetation community'
            else:
                prev_veg_com_string = self.comboBox_prevVegCom.currentText() + ' '
        else:
            prev_veg_com_string = self.comboBox_prevVegCom.currentText()
            for index in range(len(self.list_prevVegCom)):
                if index != len(self.list_prevVegCom)-1:
                    prev_veg_com_string += ', ' + self.list_prevVegCom[index].currentText()
                if index == len(self.list_prevVegCom)-1:
                    prev_veg_com_string += ' ' + self.comboBox_condTypeEnvVar.currentText() + ' ' + self.list_prevVegCom[index].currentText()
        #environmental variables
        env_var_string = '[no environmental variable selected]'
        if len(self.dict_envVar) == 0:
            if self.comboBox_envVar.currentText() == 'Empty':
                env_var_string = ' regardless of environmental variables'
            elif self.comboBox_category.currentText() == '':
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is between ' + \
                str(self.doubleSpin_rangeMin.value()) + ' and ' +str(self.doubleSpin_rangeMax.value()) + ' '
            else:
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is '+ self.comboBox_category.currentText() + ', '
        else:
            if self.comboBox_category.currentText() == '':
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is between ' + \
                str(self.doubleSpin_rangeMin.value()) + ' and ' +str(self.doubleSpin_rangeMax.value()) + ' '
            else:
                env_var_string = ', where ' + self.comboBox_envVar.currentText() + ' is '+ self.comboBox_category.currentText()+ ', '
            counter = 1
            for key in self.dict_envVar:
                if counter != len(self.dict_envVar):
                    if self.dict_envVar[key][2].currentText() != '':
                        env_var_string += key.currentText() + ' is ' + self.dict_envVar[key][2].currentText() + ', '
                        counter += 1
                    else:
                        env_var_string += key.currentText() + ' is between ' + str(self.dict_envVar[key][0].value()) + \
                                            ' and ' + str(self.dict_envVar[key][1].value()) + ', '
                        counter += 1

                else:
                    if self.dict_envVar[key][2].currentText() != '':
                        env_var_string += self.comboBox_condTypeEnvVar.currentText() + ' ' + key.currentText() + ' is ' +\
                                          self.dict_envVar[key][2].currentText()
                    else:
                        env_var_string += self.comboBox_condTypeEnvVar.currentText() + ' ' + key.currentText() + ' is between ' \
                                          + str(self.dict_envVar[key][0].value()) + ' and ' + str(self.dict_envVar[key][1].value())



        rule_string = 'Rule ' + str(self.rule_number) + ': ' + self.comboBox_ruleVegCom.currentText() + ' has ' + \
                      str(self.doubleSpin_chance.value()) + '% chance'+ rule_type_string + prev_veg_com_string + \
                      env_var_string + '.'

        if isinstance(writtenRule, QLabel):
            writtenRule.setText(rule_string)
        else:
            return rule_string
        pass

    def checkIfLegit(self): # TODO not yet functional
        """ Checks whether the all boxes have been filled in the correct way, otherwise aborts making the rule and
        gives a warning popup"""
        messageBox = QMessageBox()
        comboBoxes = [self.comboBox_ruleVegCom.currentIndex(),self.comboBox_rule.currentIndex(),self.comboBox_rule.currentIndex(),
                      self.comboBox_envVar.currentIndex()]
        if all(index ==0 for index in comboBoxes)and self.doubleSpin_chance.value() == 100 and self.n_of_envvar ==1 and self.n_of_vegcom ==1:
            messageBox.setWindowTitle('Warning')
            messageBox.setText('No changes were detected, are you sure you want to use this rule?')
        if self.comboBox_envVar.count() == 1:
            messageBox.setWindowTitle("Warning")
            messageBox.setText('No environmental variables were detected as input, are you sure you want to use this rule?')
            messageBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        #TODO Can probably think of more warnings


class MsaQgisAddTaxonPopup (QtWidgets.QDialog, FORM_CLASS_TAXA):
    def __init__(self, parent=None):
        """Popup Constructor."""
        super(MsaQgisAddTaxonPopup, self).__init__(parent)
        self.setupUi(self)


class MsaQgisAddVegComPopup (QtWidgets.QDialog, FORM_CLASS_VEGCOM):
    def __init__(self, taxonlist, parent=None):
        """Popup Constructor."""
        super(MsaQgisAddVegComPopup, self).__init__(parent)
        self.setupUi(self)
        #events
        self.pushButton_vegComAddSpecies.clicked.connect(self.addVegComTaxonRow)

        #class variables
        self.previous = 0
        self.taxon_list = taxonlist
        self.vegcom_taxon_double_list = []
        self.vegcom_taxon_combo_list = []


        #add gridlayout to scrollarea
        self.frameWidget_scroll = QFrame(self.scrollArea)
        self.frameWidget_scroll.setLayout(self.gridLayout)
        self.scrollArea.setWidget(self.frameWidget_scroll)

        #set locations of original widgets in grid (because Qt designer won't bloody work with me)

        self.gridLayout.addWidget(self.label_Title, 0, 0, 1, 4)
        self.gridLayout.addWidget(self.label_Name, 1, 0)
        self.gridLayout.addWidget(self.lineEdit_vegComName, 1, 1, 1, 4)
        self.gridLayout.setRowStretch(2, 100) #stretch middle row to maximum possible size
        self.gridLayout.addWidget(self.pushButton_vegComAddSpecies, 3, 0, 1, 4)
        self.gridLayout.addWidget(self.buttonBox_2, 4, 1, 1, 3)
        self.gridLayout.addWidget(self.buttonBox_2, 5, 0, 1, 4)

    def addVegComTaxonRow(self):
        """ Adds a new comboBox and doubleSpinBox to be able to add a new taxon to a vegetation community"""
        label = QLabel('Taxon ' + str(int((self.previous * 0.5)+1)), self)
        self.comboBox = QComboBox()
        self.doubleSpin = QDoubleSpinBox()
        # insert the new widgets
        self.gridLayout.addWidget(label, self.previous+2, 0, 1, 4)
        self.gridLayout.addWidget(self.comboBox, self.previous+3, 0, 1, 3)
        self.gridLayout.addWidget(self.doubleSpin, self.previous+3, 3, 1, 2)
        self.gridLayout.setRowStretch(self.previous + 2, 0)  # reset stretch of previously stretched row
        self.gridLayout.setRowStretch(self.previous + 4, 100)  # set new middle row to maximum stretch
        # move the widgets below to new location
        self.gridLayout.addWidget(self.pushButton_vegComAddSpecies, self.previous + 5, 0, 1, 4)
        self.gridLayout.addWidget(self.buttonBox_2, self.previous + 6, 0, 1, 4)
        self.previous += 2
        # Fill the comboBox
        self.comboBox.addItems(self.taxon_list)
        # Create list of items to pass to the main dialog
        self.vegcom_taxon_combo_list.append(self.comboBox)
        self.vegcom_taxon_double_list.append(self.doubleSpin)

class MsaQgisAddRuleToTreePopup (QtWidgets.QDialog, FORM_CLASS_RULE_TREE):
    def __init__(self, nest_rule_dict, rule_tree_type = 'Insert', parent=None):
        """Popup Constructor."""
        super(MsaQgisAddRuleToTreePopup, self).__init__(parent)
        self.setupUi(self)

        #dicts and lists
        self.nest_dict_rules = nest_rule_dict
        print(self.nest_dict_rules)

        #events
        self.comboBox_ruleToAdd.currentTextChanged.connect(self.insertRuleDescription)


        #fill UI elements
        for key in self.nest_dict_rules:
            self.comboBox_ruleToAdd.addItem(key)

        self.label_ruleTreeType.setText(rule_tree_type)

    def insertRuleDescription(self):
        self.label_writtenRule.setText(self.nest_dict_rules[self.comboBox_ruleToAdd.currentText()][1])




