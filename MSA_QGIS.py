# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MsaQgis
                                 A QGIS plugin
 This plugin allows the use of the Multi Scenario Approach in QGIS
 Boilerplate Code generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-01-14
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Thya van den Berg
        email                : w.b.van-den-berg-2020@hull.ac.uk
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 3 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program.  If not, see <https://www.gnu.org/licenses   *
 *                                                                         *
 ***************************************************************************/
"""
from csv import reader as csvreader
from pickle import dump as pickledump
from time import time, strftime, localtime
import sqlite3
import sys
from os import remove, path
from math import sqrt
#from pandas import read_csv #TODO this is currently not functional as pandas does not work in Linus QGIS and so needs to be turned off

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant, QLocale
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis._core import QgsRectangle
from qgis.core import QgsApplication, QgsMessageLog, Qgis,  QgsVectorLayer, QgsField, QgsGeometry, QgsPointXY, QgsFeature,QgsVectorLayerJoinInfo, QgsProject, QgsSpatialIndex
from qgis.utils import iface
from PyQt5.QtWidgets import QTableWidgetItem
from subprocess import Popen, PIPE, STDOUT
import traceback

# Initialize Qt resources from file resources.py. IDE will tell you it's not importing anything, IDE is wrong.
from .resources import *
# Import the code for the dialog
from .MSA_QGIS_dialog import MsaQgisDialog, MsaQgisSuccesDialog
from .MSA_QGIS_custom_sql_methods import SqlSqrt, SqlCardinalDir
from .MSA_QGIS_distance_weighting_sql_methods import SqlDwPrenticeSugita


# Import processing tools from Qgis (make sure python interpreter contains path C:\OSGeo4W64\apps\qgis\python\plugins)
home = path.expanduser("~")
sys.path.append(path.join(home, r'\OSGeo4W64\apps\qgis\python\plugins'))
from processing import run as runqgisprocess
from processing.core.Processing import Processing
Processing.initialize()

class MsaQgis:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = path.join(
            self.plugin_dir,
            'i18n',
            'MsaQgis_{}.qm'.format(locale))

        if path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MSA QGIS')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None



#** PLUGIN BUILDER FUNCTIONS
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MsaQgis', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/MSA_QGIS/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Multi Scenario Approach'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MSA QGIS'),
                action)
            self.iface.removeToolBarIcon(action)

#** CREATE SAVEFILES
    def saveRuleTreeDict(self,file_name):
        """Simplifies and saves dict_ruleTreeWidgets from the dialog, so that all UI elements are removed
        and it is optimized for use for the MSA. Things are added to a list as follows:
        [0] = next_ruleTreeWidgets (list)
        [1] = prev_ruleTreeWidgets (list)
        [2] = duplicate_ruleTreeWidgets (list)
        [3] = rule name (str)
        [4] = isBaseGroup (bool)

        :class params: self.dlg.dict_ruleTreeWidgets

        :param file_name: Contains the URL for where the simplefied rule tree dict needs to be saved to.
        :type file_name: str
        """
        dict_nest_rule_tree = {}
        for key in self.dlg.dict_ruleTreeWidgets:
            if type(self.dlg.dict_ruleTreeWidgets[key]) == list:
                nested_list = []
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key][3]) # note order is different
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key][2])
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key][4])
                visible_duplicate = min(self.dlg.dict_ruleTreeWidgets[key][4])
                nested_list.append(self.dlg.dict_ruleTreeWidgets[visible_duplicate].comboBox_name.currentText())
                nested_list.append(False)
                dict_nest_rule_tree[key] = nested_list
            else:
                nested_list = []
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key].next_ruleTreeWidgets)
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key].prev_ruleTreeWidgets)
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key].duplicate_ruleTreeWidgets)
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key].comboBox_name.currentText())
                nested_list.append(self.dlg.dict_ruleTreeWidgets[key].isBaseGroup)
                dict_nest_rule_tree[key] = nested_list
        with open (file_name, 'wb') as pkl_file:
            pickledump(dict_nest_rule_tree, pkl_file)

#** WRITE SQLite TABLES
    def createSiteTables(self, conn, cursor, basemap):
        """ Forms sql strings and executes them to create a table containing samples and associated tables with
        pollen data per sample, which it gets from the file paths given in the UI
        :class params: self.dlg

        :param conn: Sqlite connection
        :type conn: sqlite3.Connection

        :param cursor: Sqlite cursor attached to the connection
        :type cursor: sqlite3.Cursor

        :param basemap: Name of the basemap (should simply be "basemap")
        :type basemap:str"""

        QgsMessageLog.logMessage("Creation of site tables initiated", 'MSA_QGIS',
                                 Qgis.Info)
        # Create new table
        create_table_string = ' CREATE TABLE "sampling_sites"(site_name TEXT VARCHAR(50), ' \
                              'sample_x REAL, sample_y REAL, sample_is_lake BOOL, snapped_x REAL, snapped_y REAL, msa_id, PRIMARY KEY(site_name), FOREIGN KEY (msa_id) REFERENCES basemap (msa_id))'
        cursor.execute(create_table_string)
        conn.commit()
        # Fill table with data site by site from the UI
        table_sites = self.dlg.tableWidget_sites
        table_files = self.dlg.tableWidget_pollenFile
        for row in range(table_sites.rowCount()):
            insert_into_string = 'INSERT INTO "sampling_sites"(site_name, sample_x, sample_y, sample_is_lake, snapped_x, snapped_y) VALUES('
            sample_site = table_sites.item(row,0).text()
            sample_x = table_sites.item(row,1).text()
            sample_y = table_sites.item(row,2).text()
            sample_is_lake = table_sites.item(row,3).text()
            snapped_x = f'(SELECT geom_x FROM "{basemap}" WHERE geom_x BETWEEN ({sample_x}-{self.spacing*0.5}) ' \
                        f'AND ({sample_x}+{self.spacing *0.5}) ORDER BY abs({sample_x}-geom_x) limit 1)' #TODO explicitly choose one instead of random

            snapped_y = f'(SELECT geom_y FROM "{basemap}" WHERE geom_y BETWEEN ({sample_y}-{self.spacing *0.5}) ' \
                        f'AND ({sample_y}+{self.spacing*0.5}) ORDER BY abs({sample_x}-geom_y) limit 1)' #TODO explicitly choose one instead of random
            values_string = f'"{sample_site}", {sample_x}, {sample_y}, "{sample_is_lake}", {snapped_x},  {snapped_y})'
            cursor.execute(insert_into_string+values_string)
            conn.commit()
            # Create new pollen data table
            for row2 in range(table_files.rowCount()):
                if sample_site == table_files.item(row2,0).text():
                    create_table_string = f'CREATE TABLE "{sample_site}"(site_name TEXT VARCHAR(50), ' \
                                          f'taxon_code VARCHAR(20), taxon_percentage REAL, PRIMARY KEY(taxon_code))'
                    cursor.execute(create_table_string)
                    conn.commit()
                    file_name = table_files.item(row2,1).text()
                    if file_name[-4:] == '.csv':
                        with open(file_name, mode='r') as file:
                            pollen_counts_reader = csvreader(file)
                            next(pollen_counts_reader)  # Skip the first line
                            for line in pollen_counts_reader:  # Read rest of file for pollen data
                                if line[0] == 'Code':
                                    for index in range(len(line)):
                                        if line[index] == sample_site:
                                            sample_csv_index = index
                                else:
                                    insert_into_string = f'INSERT INTO "{sample_site}"(site_name, taxon_code, ' \
                                                         f' taxon_percentage) VALUES('
                                    taxon_name = line[0]
                                    taxon_percent = line[sample_csv_index]
                                    cursor.execute(f'{insert_into_string}"{sample_site}", "{taxon_name}" , {taxon_percent})')
                                    conn.commit()
        update_msa_string = f'UPDATE sampling_sites SET msa_id = (SELECT msa_id FROM "{basemap}" WHERE "{basemap}".geom_x = ' \
                            f'sampling_sites.snapped_x AND "{basemap}".geom_y = sampling_sites.snapped_y)'
        cursor.execute(update_msa_string)
        conn.commit()
        QgsMessageLog.logMessage("Creation of site tables finished", 'MSA_QGIS',
                                 Qgis.Info)

    def createTaxonTables(self, conn, cursor):
        """Forms sql strings and executes them to create tables of taxa and their characteristics,
        and of the vegetation communities and their associated taxa

        :class params: self.dlg

        :param conn: SQLite connection
        :typ conn: sqlite3.Connection

        :param cursor: SQLite cursor attached to the connection
        :type cursor: sqlite3.Cursor"""

        QgsMessageLog.logMessage("Creation of taxon tables initiated", 'MSA_QGIS',
                                Qgis.Info)
        taxa_table = self.dlg.tableWidget_taxa
        vegcom_table = self.dlg.tableWidget_vegCom

        # Create taxon table
        create_table_string = 'CREATE TABLE taxa("taxon_code" TEXT VARCHAR(20) NOT NULL, "full_name" TEXT, "fall_speed" REAL, ' \
                             '"RelPP" REAL, PRIMARY KEY(taxon_code))'
        cursor.execute(create_table_string)
        conn.commit()
        insert_string = 'INSERT INTO taxa("taxon_code", "full_name", "fall_speed", "relpp") VALUES("'
        cursor.execute('BEGIN TRANSACTION')
        for row in range(taxa_table.rowCount()):
            taxon_code = taxa_table.item(row,0).text()
            full_name = taxa_table.item(row,1).text()
            fall_speed = taxa_table.item(row,2).text()
            relative_pollen_productivity = taxa_table.item(row,3).text()
            cursor.execute((f'{insert_string}{taxon_code}", "{full_name}", "{fall_speed}", "{relative_pollen_productivity}")'))
        cursor.execute('COMMIT')

        # Create the veg com table
        create_table_string = 'CREATE TABLE vegcom("veg_com" TEXT VARCHAR(20), "taxon_code" TEXT VARCHAR(20), ' \
                              '"vegcom_percent" REAL, PRIMARY KEY("veg_com", "taxon_code"))'
        cursor.execute(create_table_string)
        conn.commit()
        insert_string = 'INSERT INTO vegcom("veg_com", "taxon_code", "vegcom_percent") VALUES("'
        cursor.execute('BEGIN TRANSACTION')
        for row in range(vegcom_table.rowCount()):
            for column in range(1,vegcom_table.columnCount()): # skip column 0 which contains the veg_com names
                veg_com_percent = vegcom_table.item(row,column).text()
                if veg_com_percent == '':
                    veg_com_percent = '0'
                veg_com = vegcom_table.item(row,0).text()
                taxon_code = vegcom_table.horizontalHeaderItem(column).text()
                cursor.execute((f'{insert_string}{veg_com}", "{taxon_code}", {veg_com_percent})'))
        cursor.execute('COMMIT')

        cursor.execute(f'CREATE TABLE vegcom_list(veg_com TEXT VARCHAR(50))')
        cursor.execute(f'INSERT INTO vegcom_list(veg_com) SELECT DISTINCT "veg_com" FROM "vegcom"')

        QgsMessageLog.logMessage("Creation of taxon tables finished", 'MSA_QGIS',
                                 Qgis.Info)

    def createTableDistanceToSite(self,conn, cursor, basemap): #TODO problematically slow
        """Creates new tables based on the coordinates of msa_id and sites ann calculates the distance and direction
        to said sites. One table is created per site

        :class params: self.dlg,
        :sql functions: self._Sqlsqrt, self._SqlCardinalDir

        :param conn: SQLite connection
        :type conn: sqlite3.Connection

        :param cursor: SQLite cursor attached to the connection
        :type cursor: sqlite3.Cursor

        :param number_of_entries: Number of entries in the database map table = number of vector points
        :type number_of_entries: int"""
        start_time = time()
        QgsMessageLog.logMessage("Creation of distance and direction tables initiated", 'MSA_QGIS',
                                 Qgis.Info)
        #count number of entries in basemap
        cursor.execute(f'SELECT * FROM "{basemap}"')
        number_of_entries = len(cursor.fetchall())
        #TODO make it work for lakes
        table_sites = self.dlg.tableWidget_sites
        cursor.execute('CREATE TABLE dist_dir(msa_id INT,site_name TEXT VARCHAR(50),geom_x REAL, ' \
                              'geom_y REAL, distance REAL, direction TEXT VARCHAR(5), PRIMARY KEY(msa_id, site_name))')
        conn.commit()
        # Create new (math) functions from python to SQLite that are not normally available. See MSA_QGIS_custom_sql_methods
        conn.create_function("SQRT", 1, SqlSqrt)
        conn.create_function("CARDDIR", 2, SqlCardinalDir)

        cursor.execute('BEGIN TRANSACTION')
        for row in range(table_sites.rowCount()):
            sample_site = table_sites.item(row,0).text()
            # # For version using non-snapped x and y
            # sample_x = table_sites.item(row,1).text()
            # sample_y = table_sites.item(row,2).text()
            # If using snapped x & y #TODO create version that uses non-snapped x,y and option to choose.
            cursor.execute(f'SELECT snapped_x FROM sampling_sites WHERE site_name = "{sample_site}"')
            snapped_x = str(cursor.fetchone()[0])
            cursor.execute(f'SELECT snapped_y FROM sampling_sites WHERE site_name = "{sample_site}"')
            snapped_y = str(cursor.fetchone()[0])

            for entry in range(1,number_of_entries+1):  #  No msa_id 1 is made, so exclude it. +1 because range is exclusive
                # Insert data per msa_id (select all of them from msa_id with x and y)
                cursor.execute(f'INSERT INTO dist_dir(msa_id, site_name, geom_x, geom_y) '
                               f'VALUES({entry}, "{sample_site}", '
                               f'(SELECT geom_x FROM "{basemap}" WHERE msa_id = {entry}), '
                               f'(SELECT geom_y FROM "{basemap}" WHERE msa_id = {entry}))')

            # Calculate distance
            update_distance_string = f'UPDATE dist_dir SET distance = (SQRT(((geom_x-{snapped_x}) * (geom_x - {snapped_x}))' \
                                     f'+ ((geom_y - {snapped_y}) * (geom_y - {snapped_y})))) WHERE site_name = "{sample_site}"'

            cursor.execute(update_distance_string)
            # Determine direction
            update_direction_string = f'UPDATE dist_dir SET direction = (SELECT CARDDIR((geom_x - {snapped_x}), ' \
                                      f'(geom_y - {snapped_y}))) WHERE site_name = "{sample_site}"'
            cursor.execute(update_direction_string)


        cursor.execute('COMMIT')
        # cursor.execute('CREATE INDEX dist_dir_dist_name_dir_idx ON dist_dir(distance, direction, site_name);')
        # conn.commit()
        cursor.execute('CREATE UNIQUE INDEX dist_dir_id_name_idx ON dist_dir(msa_id, site_name)')
        conn.commit()

        end_time = time() - start_time
        QgsMessageLog.logMessage(f"Creation of distance and direction tables finished after {end_time} seconds" , 'MSA_QGIS',
                                 Qgis.Info)

    def createTableOfMaps(self, conn, cursor):
        """Creates a table where the list of maps will go after running the main body MSA(assigning veg_coms and
        calculating pollen) including the pollen percentages calculated per taxon.

        :class params: self.dlg

        :param conn: SQLite connection
        :type conn: sqlite3.Connection

        :param cursor: SQLite cursor attached to the connection
        :type cursor: sqlite3.Cursor"""
        QgsMessageLog.logMessage("Creation of map tables initiated", 'MSA_QGIS',
                                 Qgis.Info)
        create_table_string = 'CREATE TABLE maps(map_id TEXT, iteration INT, likelihood_met BOOL, ' \
                              'like_thres_sites REAL, like_thres_cumul REAL, likelihood_cumul REAL, '
        # insert a column for likelihood scores per site
        for row in range(self.dlg.tableWidget_sites.rowCount()):
            site_name = self.dlg.tableWidget_sites.item(row, 0).text()
            site_string = f'"likelihood_{site_name}" REAL, '
            create_table_string += site_string
        # insert a column for %vegetation community per map
        for row in range(self.dlg.tableWidget_vegCom.rowCount()):
            veg_com = self.dlg.tableWidget_vegCom.item(row, 0).text()
            if row + 1 == self.dlg.tableWidget_vegCom.rowCount():  # final row
                veg_com_string = f'"percent_{veg_com}" REAL)'
                create_table_string += veg_com_string
            else:
                veg_com_string = f'"percent_{veg_com}" REAL, '
                create_table_string += veg_com_string
        cursor.execute(create_table_string)
        conn.commit()
        QgsMessageLog.logMessage("Creation of site tables finished", 'MSA_QGIS',
                                 Qgis.Info)

    def createTablePseudoPoints(self,conn,cursor, basemap):
        """ Creates a table with 4 points per sampling site that lie around the snapped x and y to avoid overcontribution of the
        point to which the site is snapped.

        :class params: self.dlg, self.spacing

        :param conn: SQLite connection
        :type conn: sqlite3.Connection

        :param cursor: SQLite cursor attached to the connection
        :type cursor: sqlite3.Cursor"""
        QgsMessageLog.logMessage("Creation of site pseudopoints table initiated", 'MSA_QGIS',
                                 Qgis.Info)

        #create table
        create_table_string = 'CREATE TABLE pseudo_points(pseudo_id INT, site_name VARCHAR(50), msa_id INT(20), ' \
                              'direction REAL, distance REAL, geom_x REAL, geom_y REAL, veg_com VARCHAR(20) DEFAULT "empty", ' \
                              'primary key(pseudo_id), FOREIGN KEY(site_name) REFERENCES sampling_sites(site_name),' \
                              f'FOREIGN KEY(msa_id) REFERENCES "{basemap}"(msa_id), FOREIGN KEY(veg_com) REFERENCES vegcom(veg_com))'
        cursor.execute(create_table_string)

        #fill table 4 points at a time
        distance = sqrt(((self.spacing*0.25)**2)*2)
        table_sites = self.dlg.tableWidget_sites
        counter = 0
        cursor.execute('BEGIN TRANSACTION')
        for row in range(table_sites.rowCount()):
            sample_site = table_sites.item(row, 0).text()

            insert_into_string = f'INSERT INTO pseudo_points(pseudo_id, site_name, msa_id, direction, distance, geom_x, geom_y) VALUES(' \
                                 f'{str(counter)}, "{sample_site}",  (SELECT msa_id FROM "sampling_sites" WHERE site_name = "{sample_site}"), "NE", {str(distance)}, ' \
                                 f'(SELECT snapped_x FROM "sampling_sites" WHERE site_name = "{sample_site}")+ {str(self.spacing*0.5)}, ' \
                                 f'(SELECT snapped_y FROM "sampling_sites" WHERE site_name = "{sample_site}")+ {str(self.spacing*0.5)})'
            cursor.execute(insert_into_string)

            insert_into_string = f'INSERT INTO pseudo_points(pseudo_id, site_name, msa_id, direction, distance, geom_x, geom_y) VALUES(' \
                                 f'{str(counter+1)}, "{sample_site}", (SELECT msa_id FROM "sampling_sites" WHERE site_name = "{sample_site}"), "SE", {str(distance)}, ' \
                                 f'(SELECT snapped_x FROM "sampling_sites" WHERE site_name = "{sample_site}")+ {str(self.spacing*0.5)}, ' \
                                 f'(SELECT snapped_y FROM "sampling_sites" WHERE site_name = "{sample_site}")- {str(self.spacing*0.5)})'
            cursor.execute(insert_into_string)

            insert_into_string = f'INSERT INTO pseudo_points(pseudo_id, site_name, msa_id, direction, distance, geom_x, geom_y) VALUES(' \
                                 f'{str(counter+2)}, "{sample_site}", (SELECT msa_id FROM "sampling_sites" WHERE site_name = "{sample_site}"), "SW", {str(distance)}, ' \
                                 f'(SELECT snapped_x FROM "sampling_sites" WHERE site_name = "{sample_site}")- {str(self.spacing*0.5)}, ' \
                                 f'(SELECT snapped_y FROM "sampling_sites" WHERE site_name = "{sample_site}")- {str(self.spacing*0.5)})'
            cursor.execute(insert_into_string)

            insert_into_string = f'INSERT INTO pseudo_points(pseudo_id, site_name, msa_id, direction, distance, geom_x, geom_y) VALUES(' \
                                 f'{str(counter+3)}, "{sample_site}",  (SELECT msa_id FROM "sampling_sites" WHERE site_name = "{sample_site}"), "NW", {str(distance)}, ' \
                                 f'(SELECT snapped_x FROM "sampling_sites" WHERE site_name = "{sample_site}")- {str(self.spacing*0.5)}, ' \
                                 f'(SELECT snapped_y FROM "sampling_sites" WHERE site_name = "{sample_site}")+ {str(self.spacing*0.5)})'
            cursor.execute(insert_into_string)
            counter += 4
        cursor.execute('COMMIT')
        QgsMessageLog.logMessage("Creation of site pseudopoints table finished", 'MSA_QGIS',
                                 Qgis.Info)

    def createTableWindrose(self, conn, cursor):
        """ Creates a SQLite table for the windrose weightings.

        :class params; self.dlg

        :param conn: SQLite connection
        :type conn: sqlite3.Connection

        :parom cursor: SQLite cursor attached to the connection
        :type cursor: sqlite3.Cursor"""
        QgsMessageLog.logMessage("Creation of windrose table initiated", 'MSA_QGIS',
                                 Qgis.Info)
        create_table_string = 'CREATE TABLE windrose(direction TEXT PRIMARY KEY, windrose_weight REAL)'
        cursor.execute(create_table_string)
        conn.commit()
        # insert_into_string = 'INSERT INTO windrose("direction", "windrose_weight") ' \
        #                      'VALUES ("N", ' + str(self.dlg.doubleSpin_north.value()) + '),' \
        #                                                                                 '("NE", ' + str(
        #     self.dlg.doubleSpin_northEast.value()) + '),' \
        #                                              '("E", ' + str(self.dlg.doubleSpin_east.value()) + '),' \
        #                                                                                                 '("SE", ' + str(
        #     self.dlg.doubleSpin_southEast.value()) + '),' \
        #                                              '("S", ' + str(self.dlg.doubleSpin_south.value()) + '),' \
        #                                                                                                  '("SW", ' + str(
        #     self.dlg.doubleSpin_southWest.value()) + '),' \
        #                                              '("W", ' + str(self.dlg.doubleSpin_west.value()) + '),' \
        #                                                                                                 '("NW", ' + str(
        #     self.dlg.doubleSpin_northWest.value()) + ');'
        #
        cursor.execute(f'INSERT INTO windrose("direction", "windrose_weight") VALUES ("N", {self.dlg.doubleSpin_north.value()}),' \
                             f'("NE", {self.dlg.doubleSpin_northEast.value()}),' \
                             f'("E", {self.dlg.doubleSpin_east.value()}),' \
                             f'("SE", {self.dlg.doubleSpin_southEast.value()}),' \
                             f'("S", {self.dlg.doubleSpin_south.value()}),' \
                             f'("SW", {self.dlg.doubleSpin_southWest.value()}),' \
                             f'("W", {self.dlg.doubleSpin_west.value()}),' \
                             f'("NW", {self.dlg.doubleSpin_northWest.value()});')
        conn.commit()

        QgsMessageLog.logMessage("Creation of windrose tables finished", 'MSA_QGIS',
                                 Qgis.Info)

    def createTablePollenLookupBasin(self, conn, cursor):
        """Creates a table with the various computed distances to the sites and determines the pollen dispersal and
        deposition function for each taxon gi(z), based on Parsons/Prentice/Sugita's (mixed) basin model.

        :class params: self.dlg,
        :sqlite functions: self._SqlDwPrenticesugita

        :param conn: SQLite connection
        :conn type: sqlite3.Connection

        :param cursor: SQLite cursor attached to the connection
        :type cursor: sqlite3.Cursor
        """
        QgsMessageLog.logMessage("Creation of distance weighted plant abundance tables initiated", 'MSA_QGIS',
                                 Qgis.Info)
        # Create table
        create_table_string = 'CREATE TABLE PollenLookup(distance REAL PRIMARY KEY, '
        for row in range(self.dlg.tableWidget_taxa.rowCount()):
            taxon = self.dlg.tableWidget_taxa.item(row, 0).text()
            if row+1 == self.dlg.tableWidget_taxa.rowCount():
                add_column_string = taxon+'_DW REAL)'
                create_table_string+=add_column_string
            else:
                add_column_string= taxon+'_DW REAL,'
                create_table_string+=add_column_string
        cursor.execute(create_table_string)
        # Insert all unique distances from dist_dir and pseudo_points
        insert_into_table = 'INSERT INTO PollenLookup(distance) SELECT DISTINCT distance FROM dist_dir'
        cursor.execute(insert_into_table)
        insert_into_table = 'INSERT INTO PollenLookup(distance) SELECT DISTINCT distance FROM pseudo_points'
        cursor.execute(insert_into_table)
        conn.commit()


        # Calculate distance weighting per taxon
        # Define distance weighting function
        cursor.execute('BEGIN TRANSACTION')
        if self.dlg.comboBox_dispModel.currentText() == 'HUMPOL mire model':
            conn.create_function("DISTANCEWEIGHT", 5, SqlDwPrenticeSugita)
            # Calculate the pollen dispersal and deposition functions
            for row in range(self.dlg.tableWidget_taxa.rowCount()):


                taxon = self.dlg.tableWidget_taxa.item(row, 0).text()
                turb_const= self.dlg.doubleSpin_turbConstant.value()
                diffusion_const = self.dlg.doubleSpin_diffConstant.value()
                wind_speed = self.dlg.doubleSpin_windSpeed.value()
                fall_speed = f'SELECT "fall_speed" FROM "taxa" WHERE "taxon_code" = "{taxon}"'
                update_DWPA_string = f'UPDATE PollenLookup SET {taxon}_DW = (SELECT DISTANCEWEIGHT({turb_const}, ' \
                                     f'{diffusion_const}, {wind_speed}, distance, ({fall_speed})))'
                cursor.execute(update_DWPA_string)

        cursor.execute('COMMIT')
        cursor.execute('CREATE INDEX PollenLookup_dist_idx ON PollenLookup(distance);')
        conn.commit()

        # Template add distance weighting function
        # elif self.dlg.comboBox_model.currentText() == '1/d':
        #     conn.create_function("DISTANCEWEIGHT", 1, self._SqlDw_OneOverD)
        #     pass
        QgsMessageLog.logMessage("Creation of distance weighted plant abundance tables finished", 'MSA_QGIS',
                                 Qgis.Info)

    def createTableCombinedPollen(self, conn, cursor):
        """Sets up an empty table that will later be filled with the simulated pollen percentages"""
        create_table_str = f'CREATE TABLE simulated_pollen(map_id TEXT, site_name TEXT, '
        for row in range(self.dlg.tableWidget_taxa.rowCount()):
            cursor.execute(f'SELECT taxon_code FROM "taxa" WHERE rowid IS {row + 1}')
            taxon = cursor.fetchone()[0]
            if row + 1 == self.dlg.tableWidget_taxa.rowCount():
                create_table_str += f'sim_{taxon}_percent REAL)'
            else:
                create_table_str += f'sim_{taxon}_percent REAL,'
        cursor.execute(create_table_str)
        conn.commit()

#** POINT SAMPLING
    def createPointLayer(self):
        """Returns a vector point layer based on the specifications given by the user in the UI

        :class params: self.spacing, self.dlg, self.iface,

        :returns: A vector layer with equally spaced points in a square as determined by the user in the UI
        :rtype: QgsVectorLayer"""
        QgsMessageLog.logMessage(f'point layer creation started', 'MSA_QGIS',Qgis.Info)
        start_time = time()

        # Create new vector point layer
        vector_point_base = QgsVectorLayer('Point', 'Name', 'memory', crs=self.crs)
        data_provider = vector_point_base.dataProvider()

        # Set extent of the new layer
        inset = self.spacing * 0.5  # set inset
        if self.dlg.extent is None:
            self.iface.messageBar().pushMessage('Extent not chosen!', level=1) # TODO will be deprecated once checkboxes in place
            raise Exception('Extent not chosen')
        else:
            x_min = self.dlg.extent.xMinimum() + inset
            x_max = self.dlg.extent.xMaximum()
            y_min = self.dlg.extent.yMinimum()
            y_max = self.dlg.extent.yMaximum() - inset

        # Create fields
            QgsMessageLog.logMessage("Initiate point creation", 'MSA_QGIS', Qgis.Info)
            # Add fields with x and y geometry and the feature id
            if self.dlg.radioButton_nestedMap.isChecked():
                data_provider.addAttributes([QgsField('geom_X', QVariant.Double, 'double', 20, 5),
                                             QgsField('geom_Y', QVariant.Double, 'double', 20, 5),
                                             QgsField('veg_com', QVariant.String),
                                             QgsField('chance_to_happen', QVariant.Int),
                                             QgsField('msa_id', QVariant.Int),
                                             QgsField('resolution', QVariant.Int)])
            else:
                data_provider.addAttributes([QgsField('geom_X', QVariant.Double, 'double', 20, 5),
                                             QgsField('geom_Y', QVariant.Double, 'double', 20, 5),
                                             QgsField('veg_com', QVariant.String),
                                             QgsField('chance_to_happen', QVariant.Int),
                                             QgsField('msa_id', QVariant.Int)])
            vector_point_base.updateFields()

        # create (simple) grid points
            feat_id_generator = 1  #QGIS 3.16 generated its own IDs, but it seems this is not the case anymore
            y = y_max
            while y >= y_min:
                x = x_min
                while x <= x_max:
                    geom = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                    feat = QgsFeature()
                    feat.setGeometry(geom)
                    feat.initAttributes(6)
                    feat.setAttribute(0, geom.asPoint().x())
                    feat.setAttribute(1, geom.asPoint().y())
                    feat.setAttribute(2, 'Empty')
                    feat.setAttribute(3, 0)
                    if self.dlg.radioButton_nestedMap.isChecked():
                        feat.setAttribute(5, self.spacing)
                        feat.setAttribute(4, None)
                    else: #setting feat ID iteratively does not work when using nesting.
                        feat.setAttribute(4, feat_id_generator)
                        feat_id_generator += 1
                    del geom
                    x += self.spacing
                    data_provider.addFeature(feat)
                    del feat
                y -= self.spacing


        #Insert higher resolution nested features
        if self.dlg.radioButton_nestedMap.isChecked():
            QgsMessageLog.logMessage(f'Implementing nested maps...', 'MSA_QGIS', Qgis.Info)
            for row in range(self.dlg.tableWidget_sites.rowCount()):
                site_x = float(self.dlg.tableWidget_sites.item(row, 1).text())
                site_y = float(self.dlg.tableWidget_sites.item(row, 2).text())
                min_x_remove = site_x - (0.5*self.dlg.spinBox_nestedArea.value())-(0.5*self.spacing)
                min_y_remove = site_y - (0.5*self.dlg.spinBox_nestedArea.value())-(0.5*self.spacing)
                max_x_remove = site_x + (0.5*self.dlg.spinBox_nestedArea.value())+(0.5*self.spacing)
                max_y_remove = site_y + (0.5*self.dlg.spinBox_nestedArea.value())+(0.5*self.spacing)
                vector_point_base.startEditing()
                vector_point_base.selectByRect(QgsRectangle(min_x_remove, min_y_remove, max_x_remove, max_y_remove))
                vector_point_base.deleteSelectedFeatures()
                vector_point_base.commitChanges()
                #get min and max x and y from the nearest non-deleted points of the outer grid.
                vector_point_base.selectByRect(QgsRectangle((site_x - (1.5*self.spacing)-(0.5*self.dlg.spinBox_nestedArea.value())),
                                                            (site_y -(0.5*self.spacing)),
                                                            (site_x - (0.5*self.spacing)-(0.5*self.dlg.spinBox_nestedArea.value())),
                                                            (site_y +(0.5*self.spacing))))
                selected_features = vector_point_base.selectedFeatures()
                min_x = selected_features[0].attribute(0) + (0.5*self.spacing) + (0.5*self.dlg.spinBox_resNested.value())
                vector_point_base.removeSelection()
                vector_point_base.selectByRect(QgsRectangle((site_x + (1.5*self.spacing)+(0.5*self.dlg.spinBox_nestedArea.value())),
                                                            (site_y -(0.5*self.spacing)),
                                                            (site_x + (0.5*self.spacing)+(0.5*self.dlg.spinBox_nestedArea.value())),
                                                            (site_y +(0.5*self.spacing))))
                selected_features = vector_point_base.selectedFeatures()
                max_x = selected_features[0].attribute(0) - (0.5*self.spacing) - (0.5*self.dlg.spinBox_resNested.value())
                vector_point_base.removeSelection()
                vector_point_base.selectByRect(QgsRectangle((site_x - (0.5*self.spacing)),
                                                            (site_y - (1.5*self.spacing)-(0.5*self.dlg.spinBox_nestedArea.value())),
                                                            (site_x + (0.5*self.spacing)),
                                                            (site_y - (0.5*self.spacing)-(0.5*self.dlg.spinBox_nestedArea.value()))))
                selected_features = vector_point_base.selectedFeatures()
                min_y = selected_features[0].attribute(1) + (0.5*self.spacing) + (0.5*self.dlg.spinBox_resNested.value())
                vector_point_base.removeSelection()
                vector_point_base.selectByRect(QgsRectangle((site_x - (0.5*self.spacing)),
                                                            (site_y + (0.5*self.spacing)+(0.5*self.dlg.spinBox_nestedArea.value())),
                                                            (site_x + (0.5*self.spacing)),
                                                            (site_y + (1.5*self.spacing)+(0.5*self.dlg.spinBox_nestedArea.value()))))
                selected_features = vector_point_base.selectedFeatures()
                max_y = selected_features[0].attribute(1) - (0.5*self.spacing) - (0.5*self.dlg.spinBox_resNested.value())
                vector_point_base.removeSelection()
                y = max_y
                while y >= min_y:
                    x = min_x
                    while x <= max_x:
                        geom = QgsGeometry.fromPointXY(QgsPointXY(x, y))
                        feat = QgsFeature()
                        feat.setGeometry(geom)
                        feat.initAttributes(6)
                        feat.setAttribute(0, geom.asPoint().x())
                        feat.setAttribute(1, geom.asPoint().y())
                        feat.setAttribute(2, 'Empty')
                        feat.setAttribute(3, 0)
                        feat.setAttribute(4, None)
                        feat.setAttribute(5, self.dlg.spinBox_resNested.value())
                        del geom
                        x += self.dlg.spinBox_resNested.value()
                        data_provider.addFeature(feat)
                        del feat
                    y -= self.dlg.spinBox_resNested.value()
                    vector_point_base.updateExtents()
                    vector_point_base.updateFields()
            #iterate over all features to add msa_id
            features = vector_point_base.getFeatures()
            feat_id_generator = 1
            vector_point_base.startEditing()
            for feat in features:
                feat[4] = feat_id_generator
                feat_id_generator +=1
                vector_point_base.updateFeature(feat)
            vector_point_base.commitChanges()

        runqgisprocess("native:createspatialindex", {'INPUT': vector_point_base})
        QgsMessageLog.logMessage("All points created", 'MSA_QGIS', Qgis.Info)
        QgsMessageLog.logMessage(f'point layer creation finished took {time()-start_time}', 'MSA_QGIS',Qgis.Info)

        return vector_point_base

    def pointSampleNative(self, point_layer):
        """ Uses native QGIS processing algorithms (joinattributesbylocation and rastersampling) to point sample
        user-selected raster and polygon layers. Method the user should use if they cannot/don't want to install
        Spatialite

         :class params: self.dlg, self.vector_point_filled_vec, self.vector_point_filled_ras
         :class params note: latter two are class variables as they need to be remembered by QGIS to be able to use them, otherwise would be deleted upon exiting function.

         :param point_layer: vector point layer with equally spaced vector points as made in createPointLayer.
         :type point_layer: QgsVectorLayer"""
        #create destination layers for vector and raster layer in memory
        #TODO speed up possible with spatial index?
        QgsMessageLog.logMessage("Native points sampling initiated", 'MSA_QGIS', Qgis.Info)
        point_layer.selectAll()
        vector_point_polygon = runqgisprocess("native:saveselectedfeatures", {'INPUT': point_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        vector_point_raster = runqgisprocess("native:saveselectedfeatures", {'INPUT': point_layer, 'OUTPUT': 'memory:'})['OUTPUT']
        runqgisprocess("native:createspatialindex", {'INPUT': vector_point_polygon})
        runqgisprocess("native:createspatialindex", {'INPUT': vector_point_raster})

        selection_table = self.dlg.tableWidget_selected
        for rows_column1 in range(selection_table.rowCount()):
            layer_name = selection_table.item(rows_column1, 0).text()
            previous_row = selection_table.item(rows_column1 - 1, 0)

            # find the next layer name in the list, if it exists #TODO simplify with range starts with rows_column_1
            for rows_column3 in range((selection_table.rowCount()) + 1):
                next_name = selection_table.item(rows_column3, 0)
                if rows_column3 <= rows_column1:  # ignore layers under current row
                    pass
                elif next_name == None:  # There is no next layer in the list
                    next_row = selection_table.item(rows_column3, 0)
                    break
                elif layer_name == next_name.text():  # Next row in the list is for the same layer, ignore
                    pass
                elif layer_name != next_name.text():  # There is a next layer in the list
                    next_row = selection_table.item(rows_column3, 0)
                    break
                else:
                    QgsMessageLog.logMessage('something went wrong in finding the next layer name',
                                             'MSA_QGIS', Qgis.Warning)
                    return

            # Check if a new layer name in the table was reached and that that is NOT the last layer in the list
            # Skip if that layer was already processed due to being in previous row
            if (previous_row == None or previous_row.text() != layer_name) \
                    and next_row != None:
                layer = QgsProject.instance().mapLayersByName(layer_name)[0]
                #clone layer to memory for speed improvement
                layer.selectAll()
                clone_layer = runqgisprocess("native:saveselectedfeatures", {'INPUT': layer, 'OUTPUT': 'memory:'})['OUTPUT']
                runqgisprocess("native:createspatialindex", {'INPUT': clone_layer})
                layer.removeSelection()

                fields = [selection_table.item(rows_column2, 1).text() for
                          rows_column2 in range(selection_table.rowCount()) if
                                                selection_table.item(rows_column2, 0).text() == layer_name]

                vector_point_polygon = runqgisprocess('qgis:joinattributesbylocation',
                                                  {'INPUT': vector_point_polygon,
                                                   'JOIN': clone_layer,
                                                   'METHOD': 0,
                                                   'PREDICATE': 0,
                                                   'JOIN_FIELDS': fields,
                                                   'OUTPUT': 'memory:'})['OUTPUT']
                runqgisprocess("native:createspatialindex", {'INPUT': vector_point_polygon})

            # Make sure that the last layer in the list has been reached
            elif next_row == None:
                # Then print the last added layer to an actual output file
                layer = QgsProject.instance().mapLayersByName(layer_name)[0]
                #clone layer to memory for speed improvement
                layer.selectAll()
                clone_layer = runqgisprocess("native:saveselectedfeatures", {'INPUT': layer, 'OUTPUT': 'memory:'})['OUTPUT']
                runqgisprocess("native:createspatialindex", {'INPUT': clone_layer})
                layer.removeSelection()
                fields = [selection_table.item(rows_column2, 1).text()
                          for rows_column2 in range(selection_table.rowCount())
                          if selection_table.item(rows_column2, 0).text() == layer_name]
                self.vector_point_filled_vec= runqgisprocess('qgis:joinattributesbylocation',
                               {'INPUT': vector_point_polygon,
                                'JOIN': clone_layer,
                                'METHOD': 0,
                                'PREDICATE': 0,
                                'JOIN_FIELDS': fields,
                                'OUTPUT': 'memory:'})['OUTPUT']
                runqgisprocess("native:createspatialindex", {'INPUT': self.vector_point_filled_vec})

                break

            elif previous_row.text() == layer_name:
                pass
            else:
                QgsMessageLog.logMessage('something went wrong around the point sampling processing algorithm',
                                         'MSA_QGIS', Qgis.Warning)
                break

        # Point sample the raster layers using sample raster values processing algorithm
        # (id: qgis:rastersampling)
        # TODO Once the plugin is functional with this option, point sample needs to be replaced with a buffer + average or median

        selection_table = self.dlg.tableWidget_selRaster
        for rows_column1 in range(selection_table.rowCount()):
            layer_name = selection_table.item(rows_column1, 0).text()
            previous_row = selection_table.item(rows_column1 - 1, 0)
            fields = []

            # find the next layer name in the list, if it exists
            for rows_column3 in range((selection_table.rowCount()) + 1):
                next_name = selection_table.item(rows_column3, 0)
                if rows_column3 <= rows_column1:  # ignore layers under current row
                    pass
                elif next_name == None:  # There is no next layer in the list
                    next_row = selection_table.item(rows_column3, 0)
                    break
                elif layer_name == next_name.text():  # Next row in the list is for the same layer, ignore
                    pass
                elif layer_name != next_name.text():  # There is a next layer in the list
                    next_row = selection_table.item(rows_column3, 0)
                    break
                else:
                    QgsMessageLog.logMessage('something went wrong in finding the next layer name - raster',
                                             'MSA_QGIS', Qgis.Warning)
                    break

            # Check if a new layer name in the table was reached and that that is NOT the last layer in the list
            # Skip if that layer was already processed due to being in previous row
            if (previous_row == None or previous_row.text() != layer_name) \
                    and next_row != None:
                layer = QgsProject.instance().mapLayersByName(layer_name)[0]
                vector_point_raster = runqgisprocess('qgis:rastersampling',
                                                  {'INPUT': vector_point_raster,
                                                   'RASTERCOPY': layer,
                                                   'COLUMN_PREFIX': layer_name[:8],
                                                   'OUTPUT': 'memory:'})['OUTPUT']
                runqgisprocess("native:createspatialindex", {'INPUT': vector_point_raster})


            # Make sure that the last layer in the list has been reached
            elif next_row == None:
                layer = QgsProject.instance().mapLayersByName(layer_name)[0]
                self.vector_point_filled_ras = runqgisprocess('qgis:rastersampling',
                               {'INPUT': vector_point_raster,
                                'RASTERCOPY': layer,
                                'COLUMN_PREFIX': layer_name[:8],
                                'OUTPUT': 'memory:'})['OUTPUT']
                runqgisprocess("native:createspatialindex", {'INPUT': self.vector_point_filled_ras})

                break

            elif previous_row.text() == layer_name:
                pass
            else:
                QgsMessageLog.logMessage('something went wrong around the processing algorithm - raster',
                                         'MSA_QGIS', Qgis.Warning)
                break


        # Join tables
        if self.dlg.tableWidget_selRaster.rowCount() == 0:
            self.vector_point_filled_ras = self.vector_point_filled_vec
        elif self.dlg.tableWidget_selected.rowCount() == 0:
            pass
        else:
            self.vector_point_filled_ras.startEditing()
            join_info = QgsVectorLayerJoinInfo()
            join_info.setJoinLayer(self.vector_point_filled_vec)
            join_info.setJoinFieldName('msa_id')
            join_info.setTargetFieldName('msa_id')
            join_info.setUsingMemoryCache(True)
            if self.dlg.radioButton_nestedMap.isChecked:
                join_info.setJoinFieldNamesBlockList(['geom_X', 'geom_Y', 'veg_com', 'chance_to_happen', 'resolution'])
            else:
                join_info.setJoinFieldNamesBlockList(['geom_X', 'geom_Y', 'veg_com', 'chance_to_happen'])
            join_info.setPrefix('')
            self.vector_point_filled_ras.addJoin(join_info)
            self.vector_point_filled_ras.updateFields()
            self.vector_point_filled_ras.commitChanges()

        QgsMessageLog.logMessage("Native points sampling finished", 'MSA_QGIS', Qgis.Info)

        # # Save the map to csv (not necessary except for testing)
        # QgsVectorFileWriter.writeAsVectorFormat(self.vector_point_filled_ras,
        #                                         self.dlg.save_directory + '\_basemap_empty_test.csv',
        #                                         'utf-8', driverName='CSV')

    def convertVectorToSql(self, save_directory):
        """ Converts QgsVectorLayer to SQLite database entry. Only used if pointSampleNative was also used.
        Connects to Sqlite db "empty_basemap.sqlite" in user given directory.

        :class params: self.dlg, self.vector_point_filled_ras"""

        #TODO times out/crashes QGIS occasionally. Find issue.

        QgsMessageLog.logMessage("Convert native qgis points to SQLite initiated", 'MSA_QGIS', Qgis.Info)
        conn = sqlite3.connect(':memory:')
        cursor = conn.cursor()
        # generate create table string (add " so the query can deal with column names and values that contain spaces
        start_string = 'CREATE TABLE Empty_basemap ('
        map_fields = self.vector_point_filled_ras.fields()
        columns_string = ''
        for field in map_fields:
            if field.name() == 'msa_id':
                primary_key_string = 'msa_id INT PRIMARY KEY '
            elif field.type() == QVariant.String or field.type() == QVariant.Char:
                length = str(field.length())
                current_column_string = f', "{field.name()}" VARCHAR({length}) '
                columns_string +=current_column_string
            elif field.type() == QVariant.Int or field.type() == QVariant.LongLong:
                current_column_string = f', "{field.name()}" INT '
                columns_string +=current_column_string
            elif field.type() == QVariant.Double:
                current_column_string = f', "{field.name()}" FLOAT '
                columns_string +=current_column_string
            else:  # I doubt anyone will be using blobs or anything... and geometry is already stored in a double
                QgsMessageLog.logMessage(f'variable of {field.name()} is wrong datatype for sql, look up Qvariant: {field.type()}',
                                         'MSA_QGIS', Qgis.Warning)

        # create the table columns
        create_table_string = f'{start_string}{primary_key_string}{columns_string});'
        cursor.execute(create_table_string)
        conn.commit()
        QgsMessageLog.logMessage("Point sampled map table created", 'MSA_QGIS', Qgis.Info)

        # fill in columns with the actual data
        map_features = self.vector_point_filled_ras.getFeatures()
        n_of_fields = len(map_fields)-1
        for feature in map_features:
            columns_string = ''
            values_string = ''
            start_string = 'INSERT INTO Empty_basemap ('
            middle_string = ') VALUES ('
            end_string = ');'
            for field in map_fields:
                if map_fields.indexFromName(field.name()) != n_of_fields:
                    columns_string += f'"{field.name()}",'
                    if feature.attribute(field.name()) == None:
                        values_string += '"", '
                    else:
                        values_string += f'"{str(feature.attribute(field.name()))}", '
                else:
                    columns_string += f'"{field.name()}"'
                    if feature.attribute(field.name()) == None:
                        values_string +='""'
                    else:
                        values_string += f'"{str(feature.attribute(field.name()))}"'

            insert_string = start_string + columns_string + middle_string + values_string + end_string
            cursor.execute(insert_string)
            conn.commit()
        string_vacuum_into = f'VACUUM INTO "{path.join(save_directory,"pointsampled_basemap.sqlite")}";'
        cursor.execute(string_vacuum_into)
        conn.commit()
        conn.close()
        QgsMessageLog.logMessage("Convert native qgis points to SQL finished", 'MSA_QGIS', Qgis.Info)

#** MISC

    def writeLogMessage(self, message, tag, level):
        """ Writes all log messages received during runtime to a file.

        :class params: self.dlg
        :param message: Message that was given to be printed in the log
        :type message: str

        :param tag: tag given to the log (e.g. Python, MSA_QGIS, SQLite)
        :type tag: str

        :param level: Level of priority of the message (info, warning, critical)
        :type level: int"""
        if tag == 'MSA_QGIS':
            file_name = path.join(self.dlg.save_directory, 'MSA_QGIS_log.txt')
            with open(file_name, 'a') as logfile:
                logfile.write(f'{strftime("D[%Y-%m-%d] T[%H:%M:%S]", localtime())} {tag}({level}): {message}\n')
        else:
            pass

    def reportStatsOnSucces(self, conn, cursor):  #TODO move to MSA_QGIS_dialog.py as this is techinically UI
        """ Loads simple stats into a popup upon succesfully running MSA QGIS

        :class param: self.succesdlg, self.dlg

        :param conn: SQLite connection
        :type conn: SQLite connection

        :param cursor: SQlite connection attached to the connection
        :type cursor: SQLite cursor"""

        total_maps_string = f'SELECT COUNT(*) FROM maps'
        cursor.execute(total_maps_string)
        total_maps = cursor.fetchone()[0]
        string_meets_fit = f'SELECT COUNT(*) FROM maps WHERE likelihood_met = "Yes"'
        cursor.execute(string_meets_fit)
        fit_met_total = cursor.fetchone()[0]
        string_percent_meets_fit = f'SELECT (SELECT ({string_meets_fit})*1.0)/ ' \
                                   f'(SELECT({total_maps})*1.0)*100.0'
        cursor.execute(string_percent_meets_fit)
        fit_met_total_percent = cursor.fetchone()[0]
        best_fit_string = f'SELECT MIN(likelihood_cumul) FROM maps'
        cursor.execute(best_fit_string)
        best_fit = cursor.fetchone()[0]
        worst_fit_string = f'SELECT MAX(likelihood_cumul) FROM maps'
        cursor.execute(worst_fit_string)
        worst_fit = cursor.fetchone()[0]
        self.succesdlg.tableWidget_stats.setItem(0, 0, QTableWidgetItem(str(total_maps)))
        self.succesdlg.tableWidget_stats.setItem(1, 0, QTableWidgetItem(str(fit_met_total)))
        self.succesdlg.tableWidget_stats.setItem(2, 0, QTableWidgetItem(str(fit_met_total_percent)))
        self.succesdlg.tableWidget_stats.setItem(3, 0, QTableWidgetItem(str(best_fit)))
        self.succesdlg.tableWidget_stats.setItem(4, 0, QTableWidgetItem(str(worst_fit)))
        row_counter = 5
        for row in range(self.dlg.tableWidget_sites.rowCount()):
            site_name = self.dlg.tableWidget_sites.item(row, 0).text()
            best_site_fit_string = f'SELECT MIN(likelihood_{site_name}) FROM maps'
            cursor.execute(best_site_fit_string)
            best_site_fit = cursor.fetchone()[0]
            worst_site_fit_string = f'SELECT MAX(likelihood_{site_name}) FROM maps'
            cursor.execute(worst_site_fit_string)
            worst_site_fit = cursor.fetchone()[0]
            self.succesdlg.tableWidget_stats.setRowCount(self.succesdlg.tableWidget_stats.rowCount() + 2)
            self.succesdlg.tableWidget_stats.setVerticalHeaderItem(row_counter, QTableWidgetItem(f'best fit {site_name}'))
            self.succesdlg.tableWidget_stats.setVerticalHeaderItem(row_counter+1, QTableWidgetItem(f'worst fit {site_name}'))
            self.succesdlg.tableWidget_stats.setItem(row_counter,0, QTableWidgetItem(str(best_site_fit)))
            self.succesdlg.tableWidget_stats.setItem(row_counter+1,0, QTableWidgetItem(str(worst_site_fit)))
            row_counter +=2

    def loadMapsToQGIS(self, conn, cursor,save_directory):
        """ Loads chosen maps into QGIS

        :class params: self.succesdlg, self.crs, self.dlg

        :param cursor: SQLite cursor
        :type cursor: SQLite cursor"""


        if self.succesdlg.radioButton_loadBest.isChecked():
            # Get map with best cumulative fit
            best_cumul_fit_map_string = f'SELECT map_id FROM maps WHERE likelihood_cumul = (SELECT MIN(likelihood_cumul) FROM maps)'
            cursor.execute(best_cumul_fit_map_string)
            fit_map = cursor.fetchone()[0]
            uri = path.join(save_directory, f'{fit_map}.csv?delimiter=,&xField=geom_x&yField=geom_y')
            uri = 'file:///' + uri
            csv_layer = QgsVectorLayer(uri, f'{fit_map}', "delimitedtext")
            csv_layer.setCrs(self.crs)
            if not csv_layer.isValid():
                QgsMessageLog.logMessage('Layer not loaded', 'MSA_QGIS', Qgis.Warning)
            else:
                QgsProject.instance().addMapLayer(csv_layer)
            pass
        elif self.succesdlg.radioButton_loadX.isChecked():
            # Get x number (user giver) of maps with highest cumulative fit.
            user_given_n = self.succesdlg.spinBox_loadX.value()
            # Get best cumulative fit map
            current_best_fit_string = f'SELECT MIN(likelihood_cumul) FROM maps'
            cursor.execute(current_best_fit_string)
            current_best_fit = cursor.fetchone()[0]
            # Load best fit map(s) (take into account that multiple maps can have the same fit)
            fit_map_string = f'SELECT map_id FROM maps WHERE likelihood_cumul = {current_best_fit}'
            cursor.execute(fit_map_string)
            fit_map_list = cursor.fetchall()
            number_of_same_fit = len(fit_map_list)
            counter = 0
            if number_of_same_fit > user_given_n:
                for map in range(user_given_n):
                    fit_map = fit_map_list[map][0]
                    QgsMessageLog.logMessage(f'opening {fit_map}', 'MSA_QGIS', Qgis.Info)
                    uri = path.join(save_directory,
                                    f'{fit_map}.csv?delimiter=,&xField=geom_x&yField=geom_y')
                    uri = 'file:///' + uri
                    csv_layer = QgsVectorLayer(uri, f'{fit_map}', "delimitedtext")
                    csv_layer.setCrs(self.crs)
                    if not csv_layer.isValid():
                        QgsMessageLog.logMessage('Layer not loaded', 'MSA_QGIS', Qgis.Warning)
                    else:
                        QgsProject.instance().addMapLayer(csv_layer)
                QgsMessageLog.logMessage(f'There are in total {number_of_same_fit} with the same fit and not all of '
                                         f'them were loaded to QGIS at runtime', 'MSA_QGIS', Qgis.Warning)
            else:
                for map in range(number_of_same_fit):
                    fit_map = fit_map_list[map][0]
                    QgsMessageLog.logMessage(f'opening {fit_map}', 'MSA_QGIS', Qgis.Info)
                    uri = path.join(save_directory,
                                    f'{fit_map}.csv?delimiter=,&xField=geom_x&yField=geom_y')
                    uri = 'file:///' + uri
                    csv_layer = QgsVectorLayer(uri, f'{fit_map}', "delimitedtext")
                    csv_layer.setCrs(self.crs)
                    if not csv_layer.isValid():
                        QgsMessageLog.logMessage('Layer not loaded', 'MSA_QGIS', Qgis.Warning)
                    else:
                        QgsProject.instance().addMapLayer(csv_layer)
                    counter += 1
                for x in range(user_given_n - number_of_same_fit):
                    # Get next best cumulative fit map and save value
                    current_best_fit_string = f'SELECT MIN(likelihood_cumul) FROM maps WHERE likelihood_cumul > {current_best_fit}'
                    cursor.execute(current_best_fit_string)
                    current_best_fit = cursor.fetchone()[0]
                    # Load now best fit map
                    fit_map_string = f'SELECT map_id FROM maps WHERE likelihood_cumul = {current_best_fit}'
                    cursor.execute(fit_map_string)
                    fit_map_list = cursor.fetchall()
                    for map in fit_map_list:
                        if counter >= user_given_n:
                            QgsMessageLog.logMessage(
                                f'There are in total {len(fit_map_list)} with the same fit as {map}'
                                f' and not all of them were loaded into QGIS at runtime', 'MSA_QGIS', Qgis.Warning)
                            return
                        fit_map = map[0]
                        QgsMessageLog.logMessage(f'opening {fit_map}', 'MSA_QGIS', Qgis.Info)
                        uri = path.join(save_directory,
                                        f'{fit_map}.csv?delimiter=,&xField=geom_x&yField=geom_y')
                        uri = 'file:///' + uri
                        csv_layer = QgsVectorLayer(uri, f'{fit_map}', "delimitedtext")
                        csv_layer.setCrs(self.crs)
                        if not csv_layer.isValid():
                            QgsMessageLog.logMessage('Layer not loaded', 'MSA_QGIS', Qgis.Warning)
                        else:
                            QgsProject.instance().addMapLayer(csv_layer)
                        counter += 1
        elif self.succesdlg.radioButton_loadFitted.isChecked():
            # Get all maps that fit
            fit_maps_string = f'SELECT map_id FROM maps WHERE likelihood_met = "Yes"'
            cursor.execute(fit_maps_string)
            fit_maps_list = cursor.fetchall()
            for map in fit_maps_list:
                fit_map = map[0]
                QgsMessageLog.logMessage(f'opening {fit_map}', 'MSA_QGIS', Qgis.Info)
                uri = path.join(save_directory, f'{fit_map}.csv?delimiter=,&xField=geom_x&yField=geom_y')
                uri = 'file:///'+uri
                csv_layer = QgsVectorLayer(uri, f'{fit_map}', "delimitedtext")
                csv_layer.setCrs(self.crs)
                if not csv_layer.isValid():
                    QgsMessageLog.logMessage('Layer not loaded', 'MSA_QGIS', Qgis.Warning)
                else:
                    QgsProject.instance().addMapLayer(csv_layer)
            pass
        elif self.succesdlg.radioButton_loadAll.isChecked():
            # Get all created maps
            get_all_maps_string = f'SELECT map_id FROM maps'
            cursor.execute(get_all_maps_string)
            all_maps_list = cursor.fetchall()
            for map in all_maps_list:
                map_to_load = map[0]
                QgsMessageLog.logMessage(f'opening {map_to_load}', 'MSA_QGIS', Qgis.Info)
                uri = path.join(save_directory, f'{map_to_load}.csv?delimiter=,&xField=geom_x&yField=geom_y')
                uri = 'file:///'+uri
                csv_layer = QgsVectorLayer(uri, f'{map_to_load}', "delimitedtext")
                csv_layer.setCrs(self.crs)
                if not csv_layer.isValid():
                    QgsMessageLog.logMessage('Layer not loaded', 'MSA_QGIS', Qgis.Warning)
                else:
                    QgsProject.instance().addMapLayer(csv_layer)
        else:
            pass  # Do not load anything

    def loadPointMap(self, point_sampled_file, save_directory, file_name = 'pointsampled_basemap.sqlite', point_or_base = 'point'):
        """ Loads a point layer csv file given by the user, checks if it's valid and changes into an SQLite file
        so it can be used further on in the process."""
        conn= sqlite3.connect(point_sampled_file)
        cursor= conn.cursor()


        if point_sampled_file[-4:] == ".csv":
            with open(point_sampled_file, 'r', newline='') as csv_file:
                reader = csvreader(csv_file)
                header_row = reader.__next__()
                # Check presence of necessary headers
                if (header_row[0] == 'msa_id' and header_row[1] == 'geom_X' and header_row[2] == 'geom_Y'
                        and header_row[3] == 'veg_com' and header_row[4] == 'chance_to_happen'):
                    pass
                else:
                    QgsMessageLog.logMessage(f'Input point sampled file invalid, missing essential header ',
                                             'MSA_QGIS', Qgis.Critical)
                    QgsMessageLog.logMessage(f'run of MSA_QGIS unsuccesful',
                                             'MSA_QGIS', Qgis.Critical)
                    return
                # Check presence of included environmental variables
                for row in range(self.dlg.tableWidget_selected.rowCount()):
                    if self.dlg.tableWidget_selected.item(row, 1).text() in header_row:
                        continue
                    else:
                        QgsMessageLog.logMessage(f'Input point sampled file invalid, missing header '
                                                 f'{self.dlg.tableWidget_selected.item(row, 1).text()}',
                                                 'MSA_QGIS', Qgis.Critical)
                        QgsMessageLog.logMessage(f'run of MSA_QGIS unsuccesful',
                                                 'MSA_QGIS', Qgis.Critical)
                        return
                if point_or_base == 'point':
                    # Check if veg_com only contains Empty
                    for row in reader:
                        if not row[3] == 'Empty':
                            QgsMessageLog.logMessage(f'Input point sampled file invalid, veg_com not empty'
                                                     f'{self.dlg.tableWidget_selected.item(row, 1).text()}',
                                                     'MSA_QGIS', Qgis.Critical)
                            QgsMessageLog.logMessage(f'run of MSA_QGIS unsuccesful',
                                                     'MSA_QGIS', Qgis.Critical)
                            return "fail"
                elif point_or_base == 'basemap':
                    # Check if veg_com contains any Empty
                    for row in reader:
                        if row[3] == 'Empty':
                            QgsMessageLog.logMessage(f'Input basemap file invalid, veg_com contains empty'
                                                     f'{self.dlg.tableWidget_selected.item(row, 1).text()}',
                                                     'MSA_QGIS', Qgis.Critical)
                            QgsMessageLog.logMessage(f'run of MSA_QGIS unsuccesful',
                                                     'MSA_QGIS', Qgis.Critical)
                            return "fail"
                # else:
                #     #TODO this is currently not functional as pandas does not work in Linux QGIS and so needs to be turned off
                #     #TODO replace with pure sqlite3 version
                #     QgsMessageLog.logMessage(f'Input point-sampled csv file invalid, currently not functional as pandas does not work in Linux QGIS and so needs to be turned off'
                #                              f'{self.dlg.tableWidget_selected.item(row, 1).text()}',
                #                              'MSA_QGIS', Qgis.Critical)
                #     csv_file = read_csv(point_sampled_file)
                #     csv_file.to_sql('empty_basemap', conn, if_exists='fail', index=False, chunksize=10000)
                #     string_vacuum_into = f'VACUUM INTO "{path.join(save_directory, file_name)}";'
                #     cursor.execute(string_vacuum_into)
                #     conn.close()
                #     return path.join(save_directory,file_name)
                else:
                    pass


        else:
            QgsMessageLog.logMessage(f'Input point sampled file invalid, not a .sqlite file ',
                                     'MSA_QGIS', Qgis.Critical)
            QgsMessageLog.logMessage(f'run of MSA_QGIS unsuccesful',
                                     'MSA_QGIS', Qgis.Critical)
            #TODO this error should be moved to UI/dialog to prevent setup of unsuccesful runs.

    def cleanQGIS(self):
        """Closes tables and maps that are no longer necessary after the point-sampled map has been made"""
        pass

#** RUN METHOD
    def run(self):
        """Run method that performs all the real work. First, the dialog is run, and once the user presses ok, the MSA
        simulations run:
        1. The initial vector layer that contains points to the user's given extent is generated.
        2. The maps given by the user are point sampled into the created vector point layer, either using QGIS native
        processing algorithms, or by using spatialite.
        3. The SQLite database that will contain the maps is generated.
        4. The basemap, using the rules for vegetation community assignment that would be the same for every scenario
        and iteration, is generated, filling the SQLite vector point map with the first set of vegetation communities.
        5a. The rules for vegetation community assignment are applied per scenario, per iteration, generating multiple
        SQLite vector point maps with the basemap as its basis.
        5b. Per map generated, the pollen load and pollen percentages are generated, and the fit is calculated compared
        to the pollen percentages given by the user. Depending on choices made by the user, pollen load, percentages,
        and/or the map are deleted if they do not fit.
        6. The kept maps and statistics on maps are generated and saved to .csv files.
        7. Simple statistics on the maps are generated, and if the user desired the simulated vegetation maps can be
        loaded into QGIS.

        :Class params related to plugin: self.first_start, self.dlg, self.succesdlg
        :Class params related to MSA: self.crs, self.spacing
        :Class methods called:
        self.createPointLayer,
        self.pointSampleNative,
        self.convertVectorToSql,
        self.pointSampleSQL
        self.createSiteTables,
        self.createTaxonTables,
        self.createTableDistanceToSite,
        self.createTablePseudoPoints,
        self.createTableOfMaps,
        self.createTablePollenLookupBasin,
        self.createTableWindrose,
        self.assignVegetationSQL,
        self.simulatePollen
        self.reportStatsOnSucces
        self.loadMapsToQGIS
        """
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = MsaQgisDialog()
            self.succesdlg = MsaQgisSuccesDialog()


        # Show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_() #TODO change so that window stays open while running main analysis
        # See if OK was pressed
        if result:
            startTime = time()
            # Things that are required independent of the type of run
            self.crs = QgsProject.instance().crs()
            self.spacing = self.dlg.spinBox_resolution.value()
            save_directory = self.dlg.save_directory

            # Start printing log messages to file
            QgsApplication.messageLog().messageReceived.connect(self.writeLogMessage)

            QgsMessageLog.logMessage("MSA_QGIS started", 'MSA_QGIS',
                                     Qgis.Info)
### point map and point sample (make or load)
            # MAKE point layer
            if self.dlg.radioButton_createMap.isChecked():
                vector_point_base = self.createPointLayer()
                try:
                    self.pointSampleNative(vector_point_base)
                    self.convertVectorToSql(save_directory)
                    QgsMessageLog.logMessage(f'point sampling, Execution time in seconds: {time() - startTime}',
                                             'MSA_QGIS',
                                             Qgis.Info)

                except Exception as e:
                    exc_type, exc_value, exc_traceback = sys.exc_info()
                    formatted_exception = traceback.format_exception(exc_type, exc_value, exc_traceback)
                    QgsMessageLog.logMessage("Exception raised, native point sampling could not run, abort run",
                                             'MSA_QGIS',
                                             Qgis.Warning)
                    QgsMessageLog.logMessage(str(formatted_exception), 'MSA_QGIS', Qgis.Critical)
                    return
                    #message = 'Point sampling failed'
                    #self.dlg.runAbortedPopup(message, e) #not yet functional
            if self.dlg.run_type < 1:
                QgsMessageLog.logMessage(
                    f'Total execution time in seconds: {time() - startTime}', 'MSA_QGIS', Qgis.Info)
                QgsMessageLog.logMessage("MSA_QGIS finished sucessfully, point_sampled map created", 'MSA_QGIS', Qgis.Info)
                return  # End run here if only a point sampled map is desired

### Make and save SQL tables and dictionaries
            self.dlg.saveRuleDict(path.join(save_directory,"temp_save_rule_dict.pkl"))
            self.saveRuleTreeDict(path.join(save_directory,"temp_save_ruletree_dict.pkl"))
            conn = sqlite3.connect(":memory:")
            cursor = conn.cursor()

            if self.dlg.radioButton_createMap.isChecked():
                file_name = path.join(save_directory, "pointsampled_basemap.sqlite")
                table_name = "Empty_basemap"
            elif self.dlg.radioButton_loadPointMap.isChecked():
                #attach pointmap sql given by user and create relevant tables (check if exist and wipe first)
                file_name = self.dlg.mQgsFileWidget_startingPoint.filePath()
                table_name = "Empty_basemap"
                if file_name[-7:] == ".sqlite":
                    pass
                    #can be opened directly, and passed on to the subprocess
                elif file_name[-4:] == ".csv":
                    #needs to be converted to .sqlite file first
                    table_name = "Empty_basemap"
                    file_name = self.loadPointMap(file_name, save_directory, 'temp_pointmap.sqlite')
                    if file_name == "fail":
                        return
            elif self.dlg.radioButton_loadBaseMap.isChecked():
                file_name = self.dlg.mQgsFileWidget_startingPoint.filePath()
                table_name = "Basemap"
                if file_name[-7:] == ".sqlite":
                    pass
                    #can be opened directly, and passed on to the subprocess
                elif file_name[-4:] == ".csv":
                    file_name = self.loadPointMap(file_name, save_directory, 'temp_basemap.sqlite')
                    if file_name == "fail":
                        return
                else:
                    QgsMessageLog.logMessage("Error, basemap not of type .sqlite", 'MSA_QGIS', Qgis.Info)
                    return
            #attach recently created map and create relevant tables
            cursor.execute(f'ATTACH DATABASE "{file_name}" AS "copy"')
            conn.commit()
            cursor.execute(f'CREATE TABLE "basemap" AS SELECT * FROM copy."{table_name}"')
            conn.commit()
            cursor.execute('DETACH DATABASE "copy"')
            conn.commit()
            cursor.execute('CREATE UNIQUE INDEX "basemap_idx" ON basemap(msa_id);')
            conn.commit()
            cursor.execute('SELECT * FROM "basemap"')
            number_of_entries = len(cursor.fetchall())
            #TODO add error catching for sampling points not within the grid.

            self.createSiteTables(conn, cursor, "basemap")
            self.createTaxonTables(conn, cursor)
            self.createTableDistanceToSite(conn, cursor, "basemap")
            self.createTableOfMaps(conn, cursor)
            self.createTablePseudoPoints(conn, cursor, "basemap")
            if self.dlg.checkBox_enableWindrose.isChecked():
                self.createTableWindrose(conn, cursor)
            self.createTablePollenLookupBasin(conn, cursor)
            self.createTableCombinedPollen(conn,cursor)

            n_of_sites = self.dlg.tableWidget_sites.rowCount()
            n_of_taxa = self.dlg.tableWidget_taxa.rowCount()
            n_of_vegcom = self.dlg.tableWidget_vegCom.rowCount()


            cursor.execute(f'VACUUM INTO "{path.join(save_directory,"temp_file_sql_input.sqlite")}";')
            conn.commit()

### full MSA
            # Requires opening a python subprocess that is not dependent on QGIS
            # As QGIS has a bug that makes multiprocessing in a plugin impossible

            #Things to send to the subprocess, must be made into str: from_basemap, number_of_iters, run_type
            if self.dlg.radioButton_loadPointMap.isChecked() or self.dlg.radioButton_createMap.isChecked(): #from_basemap
                from_basemap = "0" #subprocess should start from point sampled map and create a basemap
            elif self.dlg.radioButton_loadBaseMap.isChecked():
                from_basemap = self.dlg.mQgsFileWidget_startingPoint.filePath() #subprocess should start from basemap
            if self.dlg.run_type == 1: #run type
                #create only a basemap
                run_type = "1"
                number_of_iters = "0"
            elif self.dlg.run_type == 2:
                #runs for thought experiments
                run_type = "2"
                number_of_iters = str(self.dlg.spinBox_iter.value())
            elif self.dlg.run_type == 3:
                run_type = "3"
                number_of_iters = str(self.dlg.spinBox_iter.value())
            else:
                QgsMessageLog.logMessage("Error, run_type incorrect", 'MSA_QGIS', Qgis.Critical)
                return
            if self.dlg.radioButton_makeCsvYes.isChecked():
                make_csv_maps = "1"
            elif self.dlg.radioButton_makeCsvNo.isChecked():
                make_csv_maps = "0"
            else:
                QgsMessageLog.logMessage("Error: make csv is missing a value, check if main dialog radiobuttons have been checked correctly", 'MSA_QGIS', Qgis.Critical)
                return
            print(make_csv_maps)
            QgsMessageLog.logMessage("starting subprocess", 'MSA_QGIS', Qgis.Info)
            subprocess_time=time()
            basepath = path.dirname(path.abspath(__file__))
            file_to_run = path.join(basepath, "MSA_QGIS_Main_msa_subprocess.py")
            # running_msa = Popen(["python3", file_to_run], stdout= PIPE, stdin=PIPE, stderr=PIPE, text= True)
            #
            # subprocess_input_save_dir = running_msa.communicate(
            #     input=  f"{save_directory}\n{from_basemap}\n{run_type}\n{number_of_iters}\n{self.spacing}\n"
            #             f"{self.dlg.checkBox_enableWindrose.isChecked()}\n{self.dlg.doubleSpinBox_fit.value()}\n"
            #             f"{self.dlg.doubleSpinBox_cumulFit.value()}\n{self.dlg.comboBox_fit.currentText()}\n"
            #             f"{self.dlg.radioButton_keepFitted.isChecked()}\n{self.dlg.radioButton_keepTwo.isChecked()}\n"
            #             f"{number_of_entries}\n{self.dlg.radioButton_nestedMap.isChecked()}\n"
            #             f"{n_of_sites}\n{n_of_taxa}\n{n_of_vegcom}")[0]
            #
            # subprocess_output, subprocess_error = running_msa.communicate()
            # QgsMessageLog.logMessage(f'output = {subprocess_output} \n error = {subprocess_error}', 'MSA_QGIS', Qgis.Info)

            with Popen(["python3","-u", file_to_run], stdout= PIPE, stdin=PIPE, stderr=STDOUT, text= True, bufsize =1) as running_msa:
                running_msa.stdin.write(f"{save_directory}\n{from_basemap}\n{run_type}\n{number_of_iters}\n{self.spacing}\n"
                          f"{self.dlg.checkBox_enableWindrose.isChecked()}\n{self.dlg.doubleSpinBox_fit.value()}\n"
                          f"{self.dlg.doubleSpinBox_cumulFit.value()}\n{self.dlg.comboBox_fit.currentText()}\n"
                          f"{self.dlg.radioButton_keepFitted.isChecked()}\n{self.dlg.radioButton_keepTwo.isChecked()}\n"
                          f"{number_of_entries}\n{self.dlg.radioButton_nestedMap.isChecked()}\n"
                          f"{n_of_sites}\n{n_of_taxa}\n{n_of_vegcom}\n{self.dlg.spinBox_randomSeed.value()}\n{make_csv_maps}")
                running_msa.stdin.flush()
                running_msa.stdin.close()
                for line in running_msa.stdout:
                    QgsMessageLog.logMessage(f'{line}', 'MSA_QGIS',
                                             Qgis.Info)

            QgsMessageLog.logMessage(f"subprocess time = {time()-subprocess_time}", 'MSA_QGIS', Qgis.Info)
            QgsMessageLog.logMessage(f"processing time = {time()-startTime}", 'MSA_QGIS', Qgis.Info)
            ### Cleanup
            #remove temp files
            try:
                remove(path.join(save_directory,'temp_file_sql_input.sqlite'))
            except:
                QgsMessageLog.logMessage("Could not delete temp file temp_file_sql_input.sqlite, delete this file manually", 'MSA_QGIS', Qgis.Warning)
            try:
                remove(path.join(save_directory,'temp_save_rule_dict.pkl'))
            except:
                QgsMessageLog.logMessage("Could not delete temp file temp_save_rule_dict.pkl, delete this file manually", 'MSA_QGIS', Qgis.Warning)
            try:
                remove(path.join(save_directory,'temp_save_ruletree_dict.pkl'))
            except:
                QgsMessageLog.logMessage("Could not delete temp file temp_save_ruletree_dict.pkl, delete this file manually", 'MSA_QGIS', Qgis.Warning)


            #Let user load data after finishing
            conn = sqlite3.connect(path.join(save_directory,'MSA_output.sqlite'))
            cursor = conn.cursor()
            self.succesdlg.show()
            if run_type == "2" or run_type == "3":
                self.reportStatsOnSucces(conn, cursor)
                if self.succesdlg.exec_():
                    try:
                        self.loadMapsToQGIS(conn, cursor, save_directory)
                    except Exception as e:
                        QgsMessageLog.logMessage("Could not open maps to QGIS interface", 'MSA_QGIS', Qgis.Critical)
                        QgsMessageLog.logMessage(str(e), 'MSA_QGIS', Qgis.Critical)
            else:
                pass
                #TODO popup to indicate that point sampled map or basemap was completed.
            # Clean up connections and temporary files
            try:
                conn.close()
            except:
                pass


            executionTime = (time() - startTime)
            QgsMessageLog.logMessage(
                'Total execution time in seconds: ' + str(executionTime),'MSA_QGIS',Qgis.Info)
            QgsMessageLog.logMessage("MSA_QGIS finished sucessfully", 'MSA_QGIS', Qgis.Info)

            QgsApplication.messageLog().messageReceived.disconnect(self.writeLogMessage)
